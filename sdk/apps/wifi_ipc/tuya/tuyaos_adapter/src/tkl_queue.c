/**
 * @file tkl_queue.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "tkl_queue.h"
#include "tuya_error_code.h"
#include "uni_log.h"
#include "os_api.h"
// --- END: user defines and implements ---

typedef struct {
    OS_QUEUE *os_queue;
    INT_T msgsize;
} TKL_QUEUE;

typedef unsigned short WORD;
/**
 * @brief Create message queue
 *
 * @param[in] msgsize message size
 * @param[in] msgcount message number
 * @param[out] queue the queue handle created
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_queue_create_init(TKL_QUEUE_HANDLE *queue, INT_T msgsize, INT_T msgcount)
{
    // --- BEGIN: user implements ---

    PR_DEBUG("tkl_queue_create_init");


    if (queue == NULL || msgsize <= 0 || msgcount <= 0) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    TKL_QUEUE *tkl_queue = (TKL_QUEUE *)malloc(sizeof(TKL_QUEUE));
    if (tkl_queue == NULL) {
        return OPRT_OS_ADAPTER_QUEUE_CREAT_FAILED;
    }

    tkl_queue->os_queue = (OS_QUEUE *)malloc(sizeof(OS_QUEUE));
    if (tkl_queue->os_queue == NULL) {
        free(tkl_queue);
        return OPRT_OS_ADAPTER_QUEUE_CREAT_FAILED;
    }
    QS queue_size = (msgsize * msgcount + sizeof(WORD) - 1) / sizeof(WORD);//(msgsize + WORD_SIZE - 1) / WORD_SIZE * msgcount;
    // 创建一个存储指针的队列
    int ret = os_q_create(tkl_queue->os_queue, queue_size);
    if (ret != 0) {
        free(tkl_queue->os_queue);
        free(tkl_queue);
        return OPRT_OS_ADAPTER_QUEUE_CREAT_FAILED;
    }

    tkl_queue->msgsize = msgsize;
    *queue = (TKL_QUEUE_HANDLE)tkl_queue;
    return OPRT_OK;

    // --- END: user implements ---
}

/**
 * @brief post a message to the message queue
 *
 * @param[in] queue the handle of the queue
 * @param[in] data the data of the message
 * @param[in] timeout timeout time
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_queue_post(CONST TKL_QUEUE_HANDLE queue, VOID_T *data, UINT_T timeout)
{
    // --- BEGIN: user implements ---
    if (queue == NULL || data == NULL) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    TKL_QUEUE *tkl_queue = (TKL_QUEUE *)queue;

    // 为数据分配内存
    void *data_copy = malloc(tkl_queue->msgsize);
    if (data_copy == NULL) {
        return OPRT_OS_ADAPTER_QUEUE_SEND_FAIL;
    }

    // 复制数据
    memcpy(data_copy, data, tkl_queue->msgsize);

    // 发送数据的指针
    int ret = os_q_post(tkl_queue->os_queue, data_copy);
    if (ret == 0) {
        return OPRT_OK;
    } else {
        free(data_copy);
        return OPRT_OS_ADAPTER_QUEUE_SEND_FAIL;
    }


//    return OPRT_OK;
    // --- END: user implements ---
}
#define TKL_QUEUE_WAIT_FROEVER 0xFFFFFFFF
/**
 * @brief fetch message from the message queue
 *
 * @param[in] queue the message queue handle
 * @param[inout] msg the message fetch form the message queue
 * @param[in] timeout timeout time
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_queue_fetch(CONST TKL_QUEUE_HANDLE queue, VOID_T *msg, UINT_T timeout)
{
    // --- BEGIN: user implements ---

    if (queue == NULL) { /*|| msg == NULL)*/
        return OPRT_INVALID_PARM;
    }

    TKL_QUEUE *tkl_queue = (TKL_QUEUE *)queue;
    void *data_ptr;

    INT_T wait_ms;
    if (timeout == TKL_QUEUE_WAIT_FROEVER) {
        wait_ms = -1;
    } else {
        wait_ms = timeout;
    }

    int msg1[16] = {0};
    // 接收数据的指针
    int ret = os_q_recv(tkl_queue->os_queue, msg1, wait_ms);
    data_ptr = (void *)msg1[0];
    if (ret == 0) {
        // 复制数据到用户提供的缓冲区
        memcpy(msg, data_ptr, tkl_queue->msgsize);
        free(data_ptr);  // 释放之前分配的内存

        return OPRT_OK;
    } else {
//        printf("pend timeout");
        return OPRT_OS_ADAPTER_QUEUE_RECV_FAIL;
    }

    // --- END: user implements ---
}

/**
 * @brief free the message queue
 *
 * @param[in] queue the message queue handle
 *
 * @return VOID_T
 */
VOID_T tkl_queue_free(CONST TKL_QUEUE_HANDLE queue)
{
    // --- BEGIN: user implements ---
    PR_DEBUG("tkl_queue_free");
    if (queue == NULL) {
        return;
    }
    TKL_QUEUE *tkl_queue = (TKL_QUEUE *)queue;

    // 删除 OS 队列
    os_q_del(tkl_queue->os_queue, OS_DEL_ALWAYS);  // 假设 1 表示强制删除

    // 释放分配的内存
    if (tkl_queue->os_queue) {
        free(tkl_queue->os_queue);
    }
    if (tkl_queue) {
        free(tkl_queue);
    }
    PR_DEBUG("exit tkl_queue_free\n");


    // --- END: user implements ---
}
