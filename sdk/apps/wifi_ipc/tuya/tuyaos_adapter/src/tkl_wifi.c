/**
 * @file tkl_wifi.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "tkl_wifi.h"
#include "tuya_error_code.h"
#include "system/includes.h"
#include "app_config.h"
#include "syscfg_id.h"
#include "event/net_event.h"
#include "syscfg/syscfg_id.h"
#include "tal_log.h"
#ifdef CONFIG_NET_ENABLE
#include "wifi/wifi_connect.h"
#include "lwip.h"
#endif
// --- END: user defines and implements ---

// --- user defines ----
#define TY_WIFI_CONNECT_TIME_OUT  10
#define SCAN_MAX_AP 64
static char save_ssid_flag, request_connect_flag, ssid_scan_over;
static WIFI_REV_MGNT_CB mgnt_recv_cb = NULL;
static SNIFFER_CALLBACK sniffer_cb = NULL;
static WIFI_EVENT_CB wifi_event_cb = NULL;
static char wifi_frame_cb_switch = 0;
static bool net_cfg = false;
static WF_WK_MD_E wf_mode = WWM_STATION;//WWM_SOFTAP //WWM_STATION;
static bool scan_test = false;
static signed char jl_on_ssid[WIFI_SSID_LEN + 1] = {0}; ///< AP ssid array
static signed char jl_on_password[WIFI_PASSWD_LEN + 1] = {0}; ///< AP password arra
static signed char tuya_ssid[WIFI_SSID_LEN + 1] = {0}; ///< AP ssid array
static signed char tuya_password[WIFI_PASSWD_LEN + 1] = {0}; ///< AP password arra
static NW_IP_S jl_ip;
static u8 jl_u8_ip[4];
/*是否含有最后记忆的station配置*/
static unsigned char store_mode_save_none = 0;
/*快速启动完成*/
static unsigned char first_fast_start_flag = 0;
/*进入ap模式标志*/
static unsigned char enter_ap_mode = 0;

//extern void get_gateway(u8_t lwip_netif, char *ipaddr);
//extern void wifi_get_bssid(u8 bssid[6]);

#ifdef CONFIG_STATIC_IPADDR_ENABLE
static u8 use_static_ipaddr_flag = 0;
#endif

static int wifi_recon_Handle = NULL;
static int wifi_dhcp_timeout_Handle = NULL;
static int wifi_ap_Handle = NULL;
static struct wifi_scan_ssid_info *aplist = NULL;
static int scan_cnt = 0;
int ty_wifi_fast_connect = 0;
int tuya_set_wifi_sta_store(bool status) ;
/***********************************************************
*************************micro define***********************
***********************************************************/
#ifdef CONFIG_STATIC_IPADDR_ENABLE
struct sta_ip_info {
    u8 ssid[33];
    u32 ip;
    u32 gw;
    u32 netmask;
    u32 dns;
    u8 gw_mac[6];
    u8 local_mac[6];
    u8 chanel;
};

static void wifi_set_sta_ip_info(void)
{
    struct sta_ip_info  sta_ip_info;
    syscfg_read(VM_STA_IPADDR_INDEX, (char *) &sta_ip_info, sizeof(struct sta_ip_info));

    struct lan_setting lan_setting_info = {

        .WIRELESS_IP_ADDR0  = (u8)(sta_ip_info.ip >> 0),
        .WIRELESS_IP_ADDR1  = (u8)(sta_ip_info.ip >> 8),
        .WIRELESS_IP_ADDR2  = (u8)(sta_ip_info.ip >> 16),
        .WIRELESS_IP_ADDR3  = (u8)(sta_ip_info.ip >> 24),

        .WIRELESS_NETMASK0  = (u8)(sta_ip_info.netmask >> 0),
        .WIRELESS_NETMASK1  = (u8)(sta_ip_info.netmask >> 8),
        .WIRELESS_NETMASK2  = (u8)(sta_ip_info.netmask >> 16),
        .WIRELESS_NETMASK3  = (u8)(sta_ip_info.netmask >> 24),

        .WIRELESS_GATEWAY0   = (u8)(sta_ip_info.gw >> 0),
        .WIRELESS_GATEWAY1   = (u8)(sta_ip_info.gw >> 8),
        .WIRELESS_GATEWAY2   = (u8)(sta_ip_info.gw >> 16),
        .WIRELESS_GATEWAY3   = (u8)(sta_ip_info.gw >> 24),
    };
    TAL_PR_DEBUG("wifi_set_sta_ip_info ip =%d %d %d %d\n", lan_setting_info.WIRELESS_IP_ADDR0, lan_setting_info.WIRELESS_IP_ADDR1, lan_setting_info.WIRELESS_IP_ADDR2, lan_setting_info.WIRELESS_IP_ADDR3);
    net_set_lan_info(&lan_setting_info);
}

static int compare_dhcp_ipaddr(void)
{
    use_static_ipaddr_flag = 0;

    int ret;
    u8 local_mac[6];
    u8 gw_mac[6];
    u8 sta_channel;
    struct sta_ip_info  sta_ip_info;
    struct netif_info netif_info;

    if (net_cfg) {
        return -1;
    }
    ret = syscfg_read(VM_STA_IPADDR_INDEX, (char *) &sta_ip_info, sizeof(struct sta_ip_info));

    if (ret < 0) {
        TAL_PR_DEBUG("compare_dhcp_ipaddr NO VM_STA_IPADDR_INDEX\r\n");
        return -1;
    }

    lwip_get_netif_info(1, &netif_info);

    struct wifi_mode_info info;
    info.mode = STA_MODE;
    wifi_get_mode_cur_info(&info);

    sta_channel = wifi_get_channel();
    wifi_get_bssid(gw_mac);
    wifi_get_mac(local_mac);

    if (!strcmp(info.ssid, sta_ip_info.ssid)
        && !memcmp(local_mac, sta_ip_info.local_mac, 6)
        && !memcmp(gw_mac, sta_ip_info.gw_mac, 6)
        /*&& sta_ip_info.gw==sta_ip_info.dns//如果路由器没接网线/没联网,每次连接都去重新获取DHCP*/
       ) {
        use_static_ipaddr_flag = 1;
        TAL_PR_DEBUG("compare_dhcp_ipaddr Match\r\n");
        return 0;
    }

    TAL_PR_DEBUG("compare_dhcp_ipaddr not Match!!! ssid[%s] sta ssid[%s],local_mac[0x%x,0x%x,0x%x,0x%x,0x%x,0x%x]sta mac[0x%x,0x%x,0x%x,0x%x,0x%x,0x%x],gw_mac[0x%x,0x%x,0x%x,0x%x,0x%x,0x%x]sta gw_mac[0x%x,0x%x,0x%x,0x%x,0x%x,0x%x]\r\n", \
                 info.ssid, sta_ip_info.ssid, \
                 local_mac[0], local_mac[1], local_mac[2], local_mac[3], local_mac[4], local_mac[5], \
                 sta_ip_info.local_mac[0], sta_ip_info.local_mac[1], sta_ip_info.local_mac[2], sta_ip_info.local_mac[3], sta_ip_info.local_mac[4], sta_ip_info.local_mac[5], \
                 gw_mac[0], gw_mac[1], gw_mac[2], gw_mac[3], gw_mac[4], gw_mac[5], \
                 sta_ip_info.gw_mac[0], sta_ip_info.gw_mac[1], sta_ip_info.gw_mac[2], sta_ip_info.gw_mac[3], sta_ip_info.gw_mac[4], sta_ip_info.gw_mac[5]);

    return -1;
}

const ip_addr_t *dns_getserver(u8_t numdns);
static void store_dhcp_ipaddr(void)
{
    struct sta_ip_info  sta_ip_info = {0};
    u8 sta_channel;
    u8 local_mac[6];
    u8 gw_mac[6];

    if (use_static_ipaddr_flag) { //记忆IP匹配成功,不需要重新保存
        return;
    }

    struct netif_info netif_info;
    lwip_get_netif_info(1, &netif_info);

    struct wifi_mode_info info;
    info.mode = STA_MODE;
    wifi_get_mode_cur_info(&info);

    sta_channel = wifi_get_channel();
    wifi_get_mac(local_mac);
    wifi_get_bssid(gw_mac);

    strcpy(sta_ip_info.ssid, info.ssid);
    memcpy(sta_ip_info.gw_mac, gw_mac, 6);
    memcpy(sta_ip_info.local_mac, local_mac, 6);
    sta_ip_info.ip =  netif_info.ip;
    sta_ip_info.netmask =  netif_info.netmask;
    sta_ip_info.gw =  netif_info.gw;
    sta_ip_info.chanel = sta_channel;
    sta_ip_info.dns = *(u32 *)dns_getserver(0);

    syscfg_write(VM_STA_IPADDR_INDEX, (char *) &sta_ip_info, sizeof(struct sta_ip_info));
    TAL_PR_DEBUG("store_dhcp_ipaddr ip =%d %d %d %d\n", ((u8)(sta_ip_info.ip >> 0)) & 0xff, ((u8)(sta_ip_info.ip >> 8)) & 0xff, ((u8)(sta_ip_info.ip >> 16)) & 0xff, ((u8)(sta_ip_info.ip >> 24)) & 0xff);
    TAL_PR_DEBUG("store_dns_ipaddr ip =%d %d %d %d\n", ((u8)(sta_ip_info.dns >> 0)) & 0xff, ((u8)(sta_ip_info.dns >> 8)) & 0xff, ((u8)(sta_ip_info.dns >> 16)) & 0xff, ((u8)(sta_ip_info.dns >> 24)) & 0xff);
    puts("store_dhcp_ipaddr\r\n");
}

void dns_set_server(u32 *dnsserver)
{
    struct sta_ip_info  sta_ip_info;
    if (store_mode_save_none) {
        *dnsserver = 0;
        return;
    }
    int ret = syscfg_read(VM_STA_IPADDR_INDEX, (char *) &sta_ip_info, sizeof(struct sta_ip_info));
    if (ret <= 0) {
        *dnsserver = 0;
        TAL_PR_DEBUG("dns_set_server default dns\r\n");
    } else {
        *dnsserver = sta_ip_info.dns;
        TAL_PR_DEBUG("dns_set_server ip =%d %d %d %d\n", ((u8)(sta_ip_info.dns >> 0)) & 0xff, ((u8)(sta_ip_info.dns >> 8)) & 0xff, ((u8)(sta_ip_info.dns >> 16)) & 0xff, ((u8)(sta_ip_info.dns >> 24)) & 0xff);
    }
}
#endif


static void get_jl_ip(char *str, char *s)
{
    TAL_PR_DEBUG("get_jl_ip");
    char str_temp[8];
    int i = 0;
    TAL_PR_DEBUG("ip=%s\n", str);
    char *token = strtok(str, s);
    while (token != NULL) {
        if (i > 3) {
            break;
        }
        jl_u8_ip[i] = atoi(token);
        token = strtok(NULL, s);
        i++;
    }
}


static void wifi_set_lan_setting_info(void)
{
    TAL_PR_DEBUG("wifi_set_lan_setting_info");
    struct lan_setting lan_setting_info = {

        .WIRELESS_IP_ADDR0  = 192,
        .WIRELESS_IP_ADDR1  = 168,
        .WIRELESS_IP_ADDR2  = 1,
        .WIRELESS_IP_ADDR3  = 1,

        .WIRELESS_NETMASK0  = 255,
        .WIRELESS_NETMASK1  = 255,
        .WIRELESS_NETMASK2  = 255,
        .WIRELESS_NETMASK3  = 0,

        .WIRELESS_GATEWAY0  = 192,
        .WIRELESS_GATEWAY1  = 168,
        .WIRELESS_GATEWAY2  = 1,
        .WIRELESS_GATEWAY3  = 1,

        .SERVER_IPADDR1  = 192,
        .SERVER_IPADDR2  = 168,
        .SERVER_IPADDR3  = 1,
        .SERVER_IPADDR4  = 1,

        .CLIENT_IPADDR1  = 192,
        .CLIENT_IPADDR2  = 168,
        .CLIENT_IPADDR3  = 1,
        .CLIENT_IPADDR4  = 2,

        .SUB_NET_MASK1   = 255,
        .SUB_NET_MASK2   = 255,
        .SUB_NET_MASK3   = 255,
        .SUB_NET_MASK4   = 0,
    };

    get_jl_ip(jl_ip.ip, ".");
    lan_setting_info.WIRELESS_IP_ADDR0 = jl_u8_ip[0];
    lan_setting_info.WIRELESS_IP_ADDR1 = jl_u8_ip[1];
    lan_setting_info.WIRELESS_IP_ADDR2 = jl_u8_ip[2];
    lan_setting_info.WIRELESS_IP_ADDR3 = jl_u8_ip[3];

    lan_setting_info.SERVER_IPADDR1 = jl_u8_ip[0];
    lan_setting_info.SERVER_IPADDR2 = jl_u8_ip[1];
    lan_setting_info.SERVER_IPADDR3 = jl_u8_ip[2];
    lan_setting_info.SERVER_IPADDR4 = jl_u8_ip[3];

    lan_setting_info.CLIENT_IPADDR1 = jl_u8_ip[0];
    lan_setting_info.CLIENT_IPADDR2 = jl_u8_ip[1];
    lan_setting_info.CLIENT_IPADDR3 = jl_u8_ip[2];
    lan_setting_info.CLIENT_IPADDR4 = jl_u8_ip[3] + 1;

    get_jl_ip(jl_ip.mask, ".");

    lan_setting_info.WIRELESS_NETMASK0 = jl_u8_ip[0];
    lan_setting_info.WIRELESS_NETMASK1 = jl_u8_ip[1];
    lan_setting_info.WIRELESS_NETMASK2 = jl_u8_ip[2];
    lan_setting_info.WIRELESS_NETMASK3 = jl_u8_ip[3];

    lan_setting_info.SUB_NET_MASK1 = jl_u8_ip[0];
    lan_setting_info.SUB_NET_MASK2 = jl_u8_ip[1];
    lan_setting_info.SUB_NET_MASK3 = jl_u8_ip[2];
    lan_setting_info.SUB_NET_MASK4 = jl_u8_ip[3];

    get_jl_ip(jl_ip.gw, ".");

    lan_setting_info.WIRELESS_GATEWAY0 = jl_u8_ip[0];
    lan_setting_info.WIRELESS_GATEWAY1 = jl_u8_ip[1];
    lan_setting_info.WIRELESS_GATEWAY2 = jl_u8_ip[2];
    lan_setting_info.WIRELESS_GATEWAY3 = jl_u8_ip[3];

    net_set_lan_info(&lan_setting_info);
}

void wifi_set_default_startup_param(char *wifi_ssid, char *wifi_pwd)
{
    TAL_PR_DEBUG("wifi_set_default_startup_param");
    struct wifi_store_info wifi_default_mode_parm = {0};
    unsigned char mac_addr[6];
    char force = 0;
    char store = 0;
    memset(&wifi_default_mode_parm, 0, sizeof(struct wifi_store_info));
    switch (wf_mode) {
    case WWM_STATION:
        TAL_PR_DEBUG("|wifi_set_default_startup_param->WWM_STATION\n");
        TAL_PR_DEBUG("***********wifi ssid:%s, wifi pwd :%s*************", wifi_ssid, wifi_pwd);
        wifi_default_mode_parm.mode = STA_MODE;
        strncpy((char *)wifi_default_mode_parm.ssid[wifi_default_mode_parm.mode - STA_MODE], (const char *)wifi_ssid, sizeof(wifi_default_mode_parm.ssid[wifi_default_mode_parm.mode - STA_MODE]) - 1);
        strncpy((char *)wifi_default_mode_parm.pwd[wifi_default_mode_parm.mode - STA_MODE], (const char *)wifi_pwd, sizeof(wifi_default_mode_parm.pwd[wifi_default_mode_parm.mode - STA_MODE]) - 1);
        wifi_default_mode_parm.connect_best_network = 0;
        if (store_mode_save_none) {
            force = 1;
        } else {
            force = 0;
        }
        store = 1;
        break;

    case WWM_SOFTAP:
        wifi_set_lan_setting_info();    //AP模式配置IP地址信息和DHCP池起始分配地址
        int init_net_device_mac_addr(char *macaddr, char ap_mode); //如果AP模式需要配置SSID和MAC地址相关,需要在这里先产生MAC地址
        init_net_device_mac_addr((char *)mac_addr, 1);
        wifi_default_mode_parm.mode = AP_MODE;
        net_cfg = true;
        strncpy((char *)wifi_default_mode_parm.ssid[wifi_default_mode_parm.mode - STA_MODE], (const char *)wifi_ssid, sizeof(wifi_default_mode_parm.ssid[wifi_default_mode_parm.mode - STA_MODE]) - 1);
        strncpy((char *)wifi_default_mode_parm.pwd[wifi_default_mode_parm.mode - STA_MODE], (const char *)wifi_pwd, sizeof(wifi_default_mode_parm.pwd[wifi_default_mode_parm.mode - STA_MODE]) - 1);
        force = 1;
        store = 0;
        TAL_PR_DEBUG("|wifi_set_default_startup_param->WWM_SOFTAP\n");
        break;
    case WWM_STATIONAP:
        memset(&wifi_default_mode_parm, 0, sizeof(struct wifi_store_info));
        wifi_default_mode_parm.mode = SMP_CFG_MODE;
        break;
    }

    wifi_set_default_mode(&wifi_default_mode_parm, force, store); //配置STA模式情况下,把默认配置SSID也存储起来,以后即使保存过其他SSID,也不会覆盖丢失,使用连接最优信号SSID策略的情况下可以匹配连接
}

int tuya_set_wifi_sta_store(bool status)
{
    int ret = (int)status;
    //syscfg_write(VM_TUYA_STA_IS_STORE_IDX,&ret,sizeof(int));
}

/*
 *  设置最后记忆的模式
 */
void tuya_wifi_info_store_default_mode(int mode, const signed char *ssid, const signed char *pass)
{
    TAL_PR_DEBUG("wifi_event_callback");
    int ret = 0;
    struct wifi_mode_info wifi_info_save;

    wifi_info_save.mode = mode;
    ret = wifi_get_mode_stored_info(&wifi_info_save);
    if (ret) {
        ret = wifi_store_mode_info(mode, ssid, pass);
        tuya_set_wifi_sta_store(true);
        TAL_PR_DEBUG("|wifi_info_store_default_mode %d\n", ret);
    } else {
        if (wifi_info_save.mode != mode || strcmp(wifi_info_save.ssid, ssid) || strcmp(wifi_info_save.pwd, pass)) {
            ret = wifi_store_mode_info(mode, ssid, pass);
            tuya_set_wifi_sta_store(true);
            TAL_PR_DEBUG("|wifi_info_store_default_mode %d\n", ret);
        }
    }

}

void tuya_wifi_sta_reconnect_thread(void *arg)
{
    int count = 0;
    int recon_time = TY_WIFI_CONNECT_TIME_OUT;
    if (net_cfg) {
        mdelay(600); //1s
        wifi_enter_sta_mode(jl_on_ssid, jl_on_password);
    }

    while (1) {
        mdelay(100); //1s
        if (get_fs_is_update()) {
            break;
        }
        if (enter_ap_mode) {
            TAL_PR_DEBUG("start wifi enter_ap_mode\n");
            break;
        }
        count++;
        if (WIFI_STA_NETWORK_STACK_DHCP_SUCC == wifi_get_sta_connect_state()) {
            recon_time = 0;
            break;
        } else {
            if (count >= recon_time) {
                TAL_PR_DEBUG("start wifi reconnect **%s**\n", jl_on_ssid);
                wifi_enter_sta_mode(jl_on_ssid, jl_on_password);
                recon_time = TY_WIFI_CONNECT_TIME_OUT;
                count = 0;
            }
        }
    }
    wifi_recon_Handle = NULL;
//    vTaskDelete(NULL);
}


void print_scan_result(struct wifi_scan_ssid_info *list, int num)
{
    if (!list) {
        TAL_PR_DEBUG("list faile\n");
        return;
    }
    if (!num) {
        TAL_PR_DEBUG("num faile\n");
        return;
    }
    if (num > SCAN_MAX_AP) {
        num = SCAN_MAX_AP;
    }
    int i = 0;
    AP_IF_S *item = NULL;
    AP_IF_S *array = (AP_IF_S *)tkl_system_malloc(SIZEOF(AP_IF_S) * num);
    if (NULL == array) {
        tkl_system_free(list);
        TAL_PR_DEBUG("all_ap_scan:malloc faile\n");
        return;
    }

    memset(array, 0, SIZEOF(AP_IF_S) * num);

    for (i = 0; i < num; i++) {
        item = &array[i];

        item->channel = list[i].channel_number;
        item->rssi = list[i].rssi;

        memcpy(item->bssid, list[i].mac_addr, 6);
        strncpy((char *)item->ssid, list[i].ssid, list[i].ssid_len);
        item->s_len = list[i].ssid_len;
        // TAL_PR_DEBUG("scan ssid %s rssi %d channel_number %d\n", list[i].ssid, list[i].rssi, list[i].channel_number);
    }

    tkl_system_free(list);
}

//***************************
void wifi_reconnect()
{
//    wifi_set_sta_connect_best_ssid(1);
    if (wf_mode == WWM_POWERDOWN) {
        return;
    }
    if (wifi_get_sta_connect_state() == WIFI_STA_DISCONNECT && wf_mode == WWM_STATION) {
        struct wifi_mode_info wifi_info;
        wifi_get_mode_stored_info(&wifi_info);
        if (wifi_info.pwd == NULL || wifi_info.ssid == NULL) {
            return;
        }
        wifi_enter_sta_mode(wifi_info.ssid, wifi_info.pwd);
    }
}
//*******************
void tuya_wifi_dhcp_timeout_thread(void *arg)
{

    struct wifi_mode_info info;
    info.mode = NONE_MODE;
    wifi_get_mode_cur_info(&info);
    if (info.mode != STA_MODE) {
        wifi_enter_sta_mode(jl_on_ssid, jl_on_password);
    }
    if (NULL == wifi_recon_Handle) {
//        xTaskCreate(tuya_wifi_sta_reconnect_thread, "tuya_wifi_sta_reconnect_thread", 1024, NULL, 28, &wifi_recon_Handle);
        tkl_thread_create(&wifi_recon_Handle, "tuya_wifi_sta_reconnect_thread", 1024, 28, tuya_wifi_sta_reconnect_thread, NULL);
        TAL_PR_DEBUG("|network_user_callback tuya_wifi_dhcp_timeout_thread wifi_recon_Handle=0x%x\n", wifi_recon_Handle);
    }
    wifi_dhcp_timeout_Handle = NULL;
//    vTaskDelete(NULL);
}
static enum WIFI_EVENT s_event ;
static bool dhcp_timeout_times = 0;
static int wifi_event_callback(void *network_ctx, enum WIFI_EVENT event)
{
    TAL_PR_DEBUG("wifi_event_callback");
    struct net_event net = {0};
    net.arg = "net";
    int ret = 0;
    s_event = event;
    switch (event) {
    case WIFI_EVENT_MODULE_INIT:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_MODULE_INIT\n");
//       wifi_set_store_ssid_cnt(1);
        wifi_set_connect_sta_block(0);
        if (scan_test) {
            wifi_set_sta_connect_timeout(60);
        } else {
            wifi_set_sta_connect_timeout(TY_WIFI_CONNECT_TIME_OUT);
        }
        wifi_set_smp_cfg_timeout(180);       //配置MONITOR模式超时后事件回调通知时间
        wifi_set_default_startup_param(jl_on_ssid, jl_on_password);
        break;

    case WIFI_EVENT_MODULE_START:
        struct wifi_mode_info info;
        info.mode = NONE_MODE;
        wifi_get_mode_cur_info(&info);

        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_MODULE_START mode=%d \n", info.mode);
        if (info.mode == SMP_CFG_MODE) {
            //net.arg = "net";
            //net.event = NET_EVENT_SMP_CFG_FIRST;
            //net_event_notify(NET_EVENT_FROM_USER, &net);
        } else if (info.mode == AP_MODE) {
            wifi_rxfilter_cfg(1);
        } else if (info.mode == STA_MODE) {
            TAL_PR_DEBUG("<wifi> sta will connect, ssid(%s), pwd(%s)",
                         info.ssid,
                         info.pwd);
        }

        unsigned int  tx_rate_control_tab = // 不需要哪个速率就删除掉,可以动态设定
            0
//            | BIT(0) //0:CCK 1M
//            | BIT(1) //1:CCK 2M
//            | BIT(2) //2:CCK 5.5M
//            | BIT(3) //3:OFDM 6M
//            | BIT(4) //4:MCS0/7.2M
            | BIT(5) //5:OFDM 9M
            | BIT(6) //6:CCK 11M
            | BIT(7) //7:OFDM 12M
            | BIT(8) //8:MCS1/14.4M
            | BIT(9) //9:OFDM 18M
            | BIT(10) //10:MCS2/21.7M
            | BIT(11) //11:OFDM 24M
            | BIT(12) //12:MCS3/28.9M
            | BIT(13) //13:OFDM 36M
            | BIT(14) //14:MCS4/43.3M
            | BIT(15) //15:OFDM 48M
            | BIT(16) //16:OFDM 54M
            | BIT(17) //17:MCS5/57.8M
            | BIT(18) //18:MCS6/65.0M
            | BIT(19) //19:MCS7/72.2M
            ;
        wifi_set_tx_rate_control_tab(tx_rate_control_tab);
        //wifi_set_pwr(0);
        break;
    case WIFI_EVENT_MODULE_STOP:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_MODULE_STOP\n");
        break;

    case WIFI_EVENT_AP_START:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_AP_START,CH=%d\n", wifi_get_channel());
        enter_ap_mode = 1;
        break;
    case WIFI_EVENT_AP_STOP:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_AP_STOP\n");
        break;

    case WIFI_EVENT_STA_START:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_STA_START jl_on_ssid ssid=%s\n", jl_on_ssid);
        enter_ap_mode = 0;
        //if(NULL == wifi_recon_Handle) {
        //    xTaskCreate(tuya_wifi_sta_reconnect_thread, "tuya_wifi_sta_reconnect_thread", 1024, NULL, 28, &wifi_recon_Handle);
        //    TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_STA_START wifi_recon_Handle=0x%x\n",wifi_recon_Handle);
        //}

        break;
    case WIFI_EVENT_MODULE_START_ERR:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_MODULE_START_ERR\n");
//        wifi_event_cb(WFE_CONNECT_FAILED, NULL);
        break;
    case WIFI_EVENT_STA_STOP:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_STA_STOP\n");
        break;
    case WIFI_EVENT_STA_DISCONNECT:
        TAL_PR_DEBUG("|network_user_callback->WIFI_STA_DISCONNECT\n");
        wifi_event_cb(WFE_DISCONNECTED, NULL);

        /*----------------------------------------*/
        net.event = NET_EVENT_DISCONNECTED_AND_REQ_CONNECT;
        net_event_notify(NET_EVENT_FROM_USER, &net);
        /*----------------------------------------*/
        break;
    case WIFI_EVENT_STA_SCAN_COMPLETED:
        ssid_scan_over = 1;
        printf("scna_test:%d", scan_test);
        if (scan_test) {
            aplist = wifi_get_scan_result(&scan_cnt);
        } else {
            aplist = wifi_get_scan_result(&scan_cnt);
            print_scan_result(aplist, scan_cnt);
            //-------------------------------
            wifi_reconnect();
        }
        // TAL_PR_DEBUG("|network_user_callback->WIFI_STA_SCAN_COMPLETED\n");
        break;
    case WIFI_EVENT_STA_CONNECT_SUCC:
        TAL_PR_DEBUG("|network_user_callback->WIFI_STA_CONNECT_SUCC,CH=%d\r\n", wifi_get_channel());
#ifdef CONFIG_STATIC_IPADDR_ENABLE
        if (0 == compare_dhcp_ipaddr() && (0 == dhcp_timeout_times)) {
            wifi_set_sta_ip_info();
            ret = 1;
        }
#endif
        wifi_event_cb(WFE_CONNECTED, NULL);
        break;

    case WIFI_EVENT_MP_TEST_START:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_MP_TEST_START\n");
        break;
    case WIFI_EVENT_MP_TEST_STOP:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_MP_TEST_STOP\n");
        break;

    case WIFI_EVENT_STA_CONNECT_TIMEOUT_NOT_FOUND_SSID:
        TAL_PR_DEBUG("|network_user_callback->WIFI_STA_CONNECT_TIMEOUT_NOT_FOUND_SSID\n");
        wifi_event_cb(WFE_CONNECT_FAILED, NULL);
        /*----------------------------------------*/
        net.event = NET_CONNECT_TIMEOUT_NOT_FOUND_SSID;
        net_event_notify(NET_EVENT_FROM_USER, &net);
        /*----------------------------------------*/
        break;

    case WIFI_EVENT_STA_CONNECT_ASSOCIAT_TIMEOUT:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_STA_CONNECT_ASSOCIAT_TIMEOUT .....\n");
        break;
    case WIFI_EVENT_STA_CONNECT_ASSOCIAT_FAIL:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_STA_CONNECT_ASSOCIAT_FAIL .....\n");
        wifi_event_cb(WFE_CONNECT_FAILED, NULL);
        break;
    case WIFI_EVENT_STA_NETWORK_STACK_DHCP_SUCC:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_STA_NETWPRK_STACK_DHCP_SUCC\n");
        /*----------------------------------------*/
        extern void connect_broadcast(void);
        connect_broadcast();
        /*----------------------------------------*/
        tuya_wifi_info_store_default_mode(STA_MODE, (const signed char *)jl_on_ssid, (const signed char *)jl_on_password);
#ifdef CONFIG_STATIC_IPADDR_ENABLE
        store_dhcp_ipaddr();
#endif
        struct netif_info netif_info;
        lwip_get_netif_info(1, &netif_info);
        TAL_PR_DEBUG("DHCP ip =%d %d %d %d\n", ((u8)(netif_info.ip >> 0)) & 0xff, ((u8)(netif_info.ip >> 8)) & 0xff, ((u8)(netif_info.ip >> 16)) & 0xff, ((u8)(netif_info.ip >> 24)) & 0xff);
        request_connect_flag = 0;
        dhcp_timeout_times = 0;
        net.event = NET_EVENT_CONNECTED;
        net_event_notify(NET_EVENT_FROM_USER, &net);
        wifi_event_cb(WFE_CONNECTED, NULL);
        break;
    case WIFI_EVENT_STA_NETWORK_STACK_DHCP_TIMEOUT:
//        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_STA_NETWPRK_STACK_DHCP_TIMEOUT\n");
//        if(NULL == wifi_dhcp_timeout_Handle) {
//            xTaskCreate(tuya_wifi_dhcp_timeout_thread, "tuya_wifi_dhcp_timeout_thread", 1024, NULL, 28, &wifi_dhcp_timeout_Handle);
//            TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_STA_NETWPRK_STACK_DHCP_TIMEOUT wifi_dhcp_timeout_Handle=0x%x\n",wifi_dhcp_timeout_Handle);
//        }
        dhcp_timeout_times++;
        break;

    case WIFI_EVENT_P2P_START:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_P2P_START\n");
        break;
    case WIFI_EVENT_P2P_STOP:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_P2P_STOP\n");
        break;
    case WIFI_EVENT_P2P_GC_DISCONNECTED:
        puts("|network_user_callback->WIFI_EVENT_P2P_GC_DISCONNECTED\n");
        break;
    case WIFI_EVENT_P2P_GC_NETWORK_STACK_DHCP_SUCC:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_P2P_GC_NETWORK_STACK_DHCP_SUCC\n");
        break;
    case WIFI_EVENT_P2P_GC_NETWORK_STACK_DHCP_TIMEOUT:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_P2P_GC_NETWORK_STACK_DHCP_TIMEOUT\n");
        break;

    case WIFI_EVENT_SMP_CFG_START:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_SMP_CFG_START\n");
        break;
    case WIFI_EVENT_SMP_CFG_STOP:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_SMP_CFG_STOP\n");
        break;
    case WIFI_EVENT_SMP_CFG_TIMEOUT:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_SMP_CFG_TIMEOUT\n");
        break;
    case WIFI_EVENT_SMP_CFG_COMPLETED:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_SMP_CFG_COMPLETED\n");
        break;

    case WIFI_EVENT_PM_SUSPEND:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_PM_SUSPEND\n");
        break;
    case WIFI_EVENT_PM_RESUME:
        TAL_PR_DEBUG("|network_user_callback->WIFI_EVENT_PM_RESUME\n");
        break;
    case WIFI_EVENT_AP_ON_ASSOC:

        struct eth_addr *hwaddr = (struct eth_addr *)network_ctx;
        TAL_PR_DEBUG("WIFI_EVENT_AP_ON_ASSOC hwaddr = %02x:%02x:%02x:%02x:%02x:%02x \r\n\r\n",
                     hwaddr->addr[0], hwaddr->addr[1], hwaddr->addr[2], hwaddr->addr[3], hwaddr->addr[4], hwaddr->addr[5]);
        break;
    case WIFI_EVENT_AP_ON_DISCONNECTED:
        struct ip4_addr ipaddr;
        hwaddr = (struct eth_addr *)network_ctx;
        dhcps_get_ipaddr(hwaddr->addr, &ipaddr);
        TAL_PR_DEBUG("WIFI_EVENT_AP_ON_DISCONNECTED hwaddr = %02x:%02x:%02x:%02x:%02x:%02x, ipaddr = [%d.%d.%d.%d] \r\n\r\n",
                     hwaddr->addr[0], hwaddr->addr[1], hwaddr->addr[2], hwaddr->addr[3], hwaddr->addr[4], hwaddr->addr[5],
                     ip4_addr1(&ipaddr), ip4_addr2(&ipaddr), ip4_addr3(&ipaddr), ip4_addr4(&ipaddr));
        wifi_event_cb(WFE_DISCONNECTED, NULL);
        break;
    default:
        break;
    }
//    TAL_PR_DEBUG("return wifi_event_callback!");
    return ret;
}

//接收回调
static void wifi_rx_cb(void *rxwi, struct ieee80211_frame *wh, void *data, void *reserve)
{
    TAL_PR_DEBUG("tkl_wifi_get_bssid");
    char *str_frm_type;
    switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
    case IEEE80211_FC0_TYPE_MGT:
        switch (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) {
        case IEEE80211_FC_STYPE_ASSOC_REQ:
            str_frm_type = "association req";
            break;
        case IEEE80211_FC_STYPE_ASSOC_RESP:
            str_frm_type = "association resp";
            break;
        case IEEE80211_FC_STYPE_REASSOC_REQ:
            str_frm_type = "reassociation req";
            break;
        case IEEE80211_FC_STYPE_REASSOC_RESP:
            str_frm_type = "reassociation resp";
            break;
        case IEEE80211_FC_STYPE_PROBE_REQ:
            str_frm_type = "probe req";
            break;
        case IEEE80211_FC_STYPE_PROBE_RESP:
            str_frm_type = "probe resp";
            break;
        case IEEE80211_FC_STYPE_BEACON:
            str_frm_type = "beacon";
            break;
        case IEEE80211_FC_STYPE_ATIM:
            str_frm_type = "atim";
            break;
        case IEEE80211_FC_STYPE_DISASSOC:
            str_frm_type = "disassociation";
            break;
        case IEEE80211_FC_STYPE_AUTH:
            str_frm_type = "authentication";
            break;
        case IEEE80211_FC_STYPE_DEAUTH:
            str_frm_type = "deauthentication";
            break;
        case IEEE80211_FC_STYPE_ACTION:
            str_frm_type = "action";
            break;
        default:
            str_frm_type = "unknown mgmt";
            break;
        }
        break;
    case IEEE80211_FC0_TYPE_CTL:
        str_frm_type = "control";
        break;
    case IEEE80211_FC0_TYPE_DATA:
        str_frm_type = "data";
        break;
    default:
        str_frm_type = "unknown";
        break;

        if (mgnt_recv_cb != NULL) {
            mgnt_recv_cb((void *)data, (int)reserve);
        }
    }

    if (sniffer_cb != NULL) {
        //PRXWI_STRUC pRx = (PRXWI_STRUC)rxwi;
        sniffer_cb(data, (int)reserve, -20);
    }
}


void tuya_wifi_fast_connect_thread(void *arg)
{
#if 1
    int count = 0;
    int recon_time = 0;
    // sta模式下最多保存的SSID数目，工程中默认为5
    wifi_set_store_ssid_cnt(1);
    wifi_set_event_callback(wifi_event_callback);
    wifi_set_connect_sta_block(0);
    wifi_on();
    first_fast_start_flag = 1;
    while (1) {
        os_time_dly(1000);
    }
    // vTaskDelete(NULL);
    return;
#endif // 0
}

bool tuya_get_wifi_sta_is_store(int *status)
{
#if 0
    int ret = 0;
    ret = syscfg_read(VM_TUYA_STA_IS_STORE_IDX, status, sizeof(int));
    if (ret <= 0) {
        return false;
    } else {
        return true;
    }
#endif // 0
}

// --- end defines ----

/**
 * @brief set wifi station work status changed callback
 *
 * @param[in]      cb        the wifi station work status changed callback
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */

// #define WIFI_TEST_RX 1
OPERATE_RET tkl_wifi_init(WIFI_EVENT_CB cb)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_init!");
#if 1
    //平台事件
    wifi_event_cb = cb;
    // sta模式下最多保存的SSID数目，工程中默认为5
    wifi_set_store_ssid_cnt(1);
    // WIFI事件回调函数
    wifi_set_event_callback(wifi_event_callback);
    // wifi_on之后即可初始化服务器类型的网络应用程序
    wifi_on();

    return OPRT_OK;
#endif
    // --- END: user implements ---
}

/**
 * @brief scan current environment and obtain the ap
 *        infos in current environment
 *
 * @param[in]       ssid        the specific ssid
 * @param[out]      ap_ary      current ap info array
 * @param[out]      num         the num of ar_ary
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 *
 * @note if ssid == NULL means scan all ap, otherwise means scan the specific ssid
 */
OPERATE_RET tkl_wifi_scan_ap(CONST SCHAR_T *ssid, AP_IF_S **ap_ary, UINT_T *num)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_scan_ap!");
    int timeout = 0 ;
    AP_IF_S *item;
    AP_IF_S *array = NULL;
    WF_WK_MD_E last_wf_mode = wf_mode;
    int scan_result = 0;
    int wifi_pre_is_on = 0;
    char wifi_cur_name[WIFI_SSID_LEN + 1] = {0};
    char wifi_cur_pw[WIFI_PASSWD_LEN + 1] = {0};
    int i, j;
    if (ssid == NULL) {
        TAL_PR_DEBUG("tkl_wifi_scan_ap ssid null!");
        if ((NULL == ap_ary) || (NULL == num)) {
            TAL_PR_DEBUG("all_ap_scan argerr\n");
            return OPRT_OS_ADAPTER_INVALID_PARM;
        }
        memcpy(wifi_cur_name, jl_on_ssid, WIFI_SSID_LEN + 1);
        memcpy(wifi_cur_pw, jl_on_password, WIFI_PASSWD_LEN + 1);
//        memcpy(jl_on_ssid, "TP-LINK_30E7", WIFI_SSID_LEN+1);
//        memcpy(jl_on_password, "12345678", WIFI_PASSWD_LEN+1);
        TAL_PR_DEBUG("all_ap_scan adapt\n");
        scan_test = true;
        if (wifi_is_on()) {
            wifi_pre_is_on = 1;
            wifi_off();
            while (wifi_is_on()) {
                mdelay(50);
            }
            mdelay(10);
        }

        wifi_set_event_callback(wifi_event_callback);
        wifi_on();
        mdelay(50);

        ssid_scan_over = 0;
        wifi_scan_req();
        while (ssid_scan_over == 0) {
            mdelay(1);
            timeout++;
            if (timeout > 650) {
                TAL_PR_DEBUG("all_ap_scan timeout\n");
                break;
            }

        }
        scan_test = false;
        if (aplist && scan_cnt) {
            if (scan_cnt > SCAN_MAX_AP) {
                scan_cnt = SCAN_MAX_AP;
            }

            array = (AP_IF_S *)tkl_system_malloc(SIZEOF(AP_IF_S) * scan_cnt);
            if (NULL == array) {
                tkl_system_free(aplist);
                aplist = NULL;
                TAL_PR_DEBUG("all_ap_scan:malloc faile\n");
                scan_result = OPRT_OS_ADAPTER_COM_ERROR;
                goto SCAN_OVER;
            }

            memset(array, 0, SIZEOF(AP_IF_S) * scan_cnt);

            for (i = 0; i < scan_cnt; i++) {
                item = &array[i];

                item->channel = aplist[i].channel_number;
                item->rssi = aplist[i].rssi;

                memcpy(item->bssid, aplist[i].mac_addr, 6);
                strncpy((char *)item->ssid, aplist[i].ssid, aplist[i].ssid_len);
                item->s_len = aplist[i].ssid_len;
                TAL_PR_DEBUG("all_ap_scan ssid %s rssi %d\n", aplist[i].ssid, aplist[i].rssi);
            }

            *ap_ary = array;
            *num = scan_cnt & 0xff;

            tkl_system_free(aplist);
            aplist = NULL;
            TAL_PR_DEBUG("all_ap_scan ok :%d\n", *num);

            scan_result = OPRT_OK;
        } else {
            TAL_PR_DEBUG("all_ap_scan fail %d %d\n", aplist, scan_cnt);
            scan_result = OPRT_OS_ADAPTER_COM_ERROR;
        }
    } else {
        TAL_PR_DEBUG("tkl_wifi_scan_ap ssid not null!");
        scan_test = true;
        TAL_PR_DEBUG("assign_ap_scan adapt\n");
        memcpy(wifi_cur_name, jl_on_ssid, WIFI_SSID_LEN + 1);
        memcpy(wifi_cur_pw, jl_on_password, WIFI_PASSWD_LEN + 1);
//        memcpy(jl_on_ssid,"tuya_wifi_!@#$%&^",WIFI_SSID_LEN+1);
//        memcpy(jl_on_password,"12345678",WIFI_PASSWD_LEN+1);
        memcpy(jl_on_ssid, "TP-LINK_30E7", WIFI_SSID_LEN + 1);
        memcpy(jl_on_password, "12345678", WIFI_PASSWD_LEN + 1);
        if (wifi_is_on()) {
            wifi_pre_is_on = 1;
            wifi_off();
            while (wifi_is_on()) {
                mdelay(50);
            }
            mdelay(10);
        }

        wf_mode = WWM_STATION;
        wifi_set_event_callback(wifi_event_callback);
        wifi_on();
        mdelay(50);

        ssid_scan_over = 0;
        scan_result = wifi_scan_req();
        TAL_PR_DEBUG("wifi_scan_req %d\n", scan_result);
        while (ssid_scan_over == 0) {
            mdelay(1);
            timeout++;
            if (timeout > 650) {
                TAL_PR_DEBUG("all_ap_scan timeout\n");
                break;
            }
        }
        scan_test = false;
        if (NULL == aplist || scan_cnt == 0) {
            TAL_PR_DEBUG("wifi_get_scan_result aplist null\n");
            scan_result = OPRT_INVALID_PARM;
            goto SCAN_OVER;
        }

        array = (AP_IF_S *)tkl_system_malloc(SIZEOF(AP_IF_S));
        if (NULL == array) {
            tkl_system_free(aplist);
            aplist = NULL;
            TAL_PR_DEBUG("wifi_assign_ap_scan:malloc faile\n");
            scan_result = OPRT_OS_ADAPTER_COM_ERROR;
            goto SCAN_OVER;
        }

        memset(array, 0, sizeof(AP_IF_S));
        array->rssi = -100;

        for (i = 0; i < scan_cnt; i++) {
            TAL_PR_DEBUG("all_ap_scan ssid %s rssi %d\n", aplist[i].ssid, aplist[i].rssi);
            if (strcmp(aplist[i].ssid, ssid)) {
                continue;
            }

            if (aplist[i].rssi < array->rssi) {
                continue;
            }

            array->channel = aplist[i].channel_number; //信道
            array->rssi = aplist[i].rssi;              //rssi强度

            memcpy(array->bssid, aplist[i].mac_addr, 6); //bssid
            strncpy((char *)array->ssid, aplist[i].ssid, aplist[i].ssid_len); //ssid
            array->s_len = aplist[i].ssid_len; //ssid长度
            j++;
        }

        if (j == 0) {
            TAL_PR_DEBUG("not have this ssid!");
            goto SCAN_ERR;
        }

        *ap_ary = array;
        if (aplist != NULL) {
            tkl_system_free(aplist);
            aplist = NULL;
        }
        scan_result = OPRT_OK;
    }

SCAN_OVER:
    memcpy(jl_on_ssid, wifi_cur_name, WIFI_SSID_LEN + 1);
    memcpy(jl_on_password, wifi_cur_pw, WIFI_PASSWD_LEN + 1);
    wf_mode = last_wf_mode;
    wifi_off();
    while (wifi_is_on()) {
        mdelay(50);
    }
    if (wifi_pre_is_on) {
        wifi_on();
    }
    return scan_result;

SCAN_ERR:
    memcpy(jl_on_ssid, wifi_cur_name, WIFI_SSID_LEN + 1);
    memcpy(jl_on_password, wifi_cur_pw, WIFI_PASSWD_LEN + 1);
    wf_mode = last_wf_mode;
    wifi_off();
    while (wifi_is_on()) {
        mdelay(50);
    }
    if (wifi_pre_is_on) {
        wifi_on();
    }
    if (aplist != NULL) {
        tkl_system_free(aplist);
        aplist = NULL;
    }
    if (array) {
        tkl_system_free(array);
        array = NULL;
    }
    return OPRT_OS_ADAPTER_COM_ERROR;
    // --- END: user implements ---
}

/**
 * @brief release the memory malloced in <tkl_wifi_ap_scan>
 *        if needed. tuyaos will call this function when the
 *        ap info is no use.
 *
 * @param[in]       ap          the ap info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_release_ap(AP_IF_S *ap)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_get_bssid");
    if (NULL == ap) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    tkl_system_free(ap);
    ap = NULL;

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief start a soft ap
 *
 * @param[in]       cfg         the soft ap config
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_start_ap(CONST WF_AP_CFG_IF_S *cfg)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_get_bssid");
    int timeout = 0;
    net_cfg = true;

    TAL_PR_DEBUG("ap adapt_wifi_set:%s \n", cfg->ssid);
#if 0
    enter_ap_mode = 1;
    memset(jl_on_ssid, 0, sizeof(jl_on_ssid));
    memcpy(jl_on_ssid, cfg->ssid, strlen(cfg->ssid));

    memset(jl_on_password, 0, sizeof(jl_on_password));
    memcpy(jl_on_password, cfg->passwd, strlen(cfg->passwd));

    memcpy(&jl_ip, &(cfg->ip), sizeof(NW_IP_S));

    if (wifi_is_on()) {
        wifi_off();
        while (wifi_is_on()) {
            mdelay(50);
        }
    }
    wifi_set_event_callback(wifi_event_callback);
    wifi_on();
#endif
    return OPRT_OK;
//    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief stop a soft ap
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_stop_ap(VOID_T)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_get_bssid");
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief set wifi interface work channel
 *
 * @param[in]       chan        the channel to set
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_cur_channel(CONST UCHAR_T chan)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_get_bssid");
    if ((chan > 14) || (chan < 1)) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    TAL_PR_DEBUG("adapt_set_wifi_channel:%d\n", chan);

    wifi_set_channel((unsigned char)chan);

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief get wifi interface work channel
 *
 * @param[out]      chan        the channel wifi works
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_cur_channel(UCHAR_T *chan)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_get_bssid");
    *chan = (unsigned char)wifi_get_channel();
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief enable / disable wifi sniffer mode.
 *        if wifi sniffer mode is enabled, wifi recv from
 *        packages from the air, and user shoud send these
 *        packages to tuya-sdk with callback <cb>.
 *
 * @param[in]       en          enable or disable
 * @param[in]       cb          notify callback
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_sniffer(CONST BOOL_T en, CONST SNIFFER_CALLBACK cb)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_get_bssid");
    TAL_PR_DEBUG("sniffer_set: %d \n", en);
    if (en != 0 || NULL == cb) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }
    if (en) {
        WF_WK_MD_E mode = WWM_POWERDOWN;
        tkl_wifi_get_work_mode(&mode);
        if ((mode == WWM_SOFTAP) || (mode == WWM_STATIONAP)) {
        } else {
            sniffer_cb = cb;
            if (wifi_frame_cb_switch == 0) {
                wifi_frame_cb_switch = 1;
                //wifi_enter_smp_cfg_mode();
                //wifi_set_frame_cb(wifi_rx_cb);  //注册接收802.11数据帧回调
            }
        }

    } else {
        sniffer_cb = NULL;
        if (mgnt_recv_cb == NULL) {
            wifi_frame_cb_switch = 0;
            //wifi_set_frame_cb(NULL);
        }
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief get wifi ip info.when wifi works in
 *        ap+station mode, wifi has two ips.
 *
 * @param[in]       wf          wifi function type
 * @param[out]      ip          the ip addr info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_ip(CONST WF_IF_E wf, NW_IP_S *ip)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_get_bssid");
    char ipaddr[16] = {0};
    char gateway[16] = {0};

    Get_IPAddress(1, ipaddr);
    get_gateway(1, gateway);

    strcpy(ip->ip, ipaddr);
    strcpy(ip->mask, "255.255.255.0");
    strcpy(ip->gw, gateway);

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief get wifi ip info.when wifi works in
 *        ap+station mode, wifi has two ips.
 *
 * @param[in]       wf          wifi function type
 * @param[in]       wf          wifi ip type
 * @param[out]      ip          the ip addr info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_ipv6(CONST WF_IF_E wf, NW_IP_TYPE type, NW_IP_S *ip)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief wifi set ip
 *
 * @param[in]       wf     wifi function type
 * @param[in]       ip     the ip addr info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_ip(CONST WF_IF_E wf, NW_IP_S *ip)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_set_ip");
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief set wifi mac info.when wifi works in
 *        ap+station mode, wifi has two macs.
 *
 * @param[in]       wf          wifi function type
 * @param[in]       mac         the mac info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_mac(CONST WF_IF_E wf, CONST NW_MAC_S *mac)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_set_mac");
    int error;

    unsigned char mac_read[6];

//
    wifi_set_mac((char *)mac->mac);
#if 1
    error = syscfg_write(VM_TUYA_MAC_IDX, mac->mac, 6);

    TAL_PR_DEBUG("syscfg_write :%x %d\r\n", error, error);

    syscfg_read(VM_TUYA_MAC_IDX, mac_read, 6);

    TAL_PR_DEBUG("adapt_set_wifi_mac_read:%x %x %x %x %x %x\n", mac_read[0], mac_read[1], mac_read[2], mac_read[3], mac_read[4], mac_read[5]);
#endif // 0
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief get wifi mac info.when wifi works in
 *        ap+station mode, wifi has two macs.
 *
 * @param[in]       wf          wifi function type
 * @param[out]      mac         the mac info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_mac(CONST WF_IF_E wf, NW_MAC_S *mac)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_get_mac");
    u8 mac_t[6];

    syscfg_read(VM_TUYA_MAC_IDX, mac_t, 6);
    // wifi_get_mac(mac_t);
    memcpy(mac->mac, mac_t, sizeof(mac_t));

    TAL_PR_DEBUG("tkl_wifi_get_mac:%x %x %x %x %x %x\n", mac->mac[0], mac->mac[1], mac->mac[2], mac->mac[3], mac->mac[4], mac->mac[5]);
    return OPRT_OK;
//    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief set wifi work mode
 *
 * @param[in]       mode        wifi work mode
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_work_mode(CONST WF_WK_MD_E mode)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_set_work_mode");
    OPERATE_RET ret = OPRT_OK;
    WF_WK_MD_E current_mode;
    int timeout = 0;

    ret = tkl_wifi_get_work_mode(&current_mode);
    if ((OPRT_OK == ret) && (current_mode != mode)) {
    }

    //设置wifi mode
    switch (mode) {
    case WWM_POWERDOWN :
        //关闭wifi模块
        puts("adapt_wifi_set_work_mode[WWM_LOWPOWER]\n");
        wf_mode = WWM_POWERDOWN;
        break;

    case WWM_SNIFFER :
        puts("adapt_wifi_set_work_mode[WWM_SNIFFER]\n");
        wf_mode = WWM_SNIFFER;
        break;

    case WWM_STATION :
        puts("adapt_wifi_set_work_mode[WWM_STATION]\n");
        wf_mode = WWM_STATION;
        break;

    case WWM_SOFTAP :
        puts("adapt_wifi_set_work_mode[WWM_SOFTAP]\n");
        wf_mode = WWM_SOFTAP;
        break;

    case WWM_STATIONAP :
        puts("adapt_wifi_set_work_mode[WWM_STATIONAP]\n");
        wf_mode = WWM_STATIONAP;
        break;

    default:
        puts("adapt_wifi_set_work_mode[default]\n");
        break;
    }
    return OPRT_OK;
//    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief get wifi work mode
 *
 * @param[out]      mode        wifi work mode
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_work_mode(WF_WK_MD_E *mode)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_get_work_mode, wf_mode = %d", wf_mode);
    if (NULL == mode) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }
    *mode = wf_mode;
    return OPRT_OK;
    // --- END: user implements ---
}

struct FAST_WF_CONNECTED_AP_INFO_S {
    char ssid[WIFI_SSID_LEN + 1];
    char pwd[WIFI_SSID_LEN + 1];
};


/**
 * @brief : get ap info for fast connect
 * @param[out]      fast_ap_info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_connected_ap_info(FAST_WF_CONNECTED_AP_INFO_T **fast_ap_info)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_get_connected_ap_info");
//    memset(fast_ap_info, 0, sizeof(FAST_WF_CONNECTED_AP_INFO_T));
//    struct wifi_mode_info mode_info;
//    mode_info.mode = STA_MODE;
//    wifi_get_mode_cur_info(&mode_info);


#if 0
    unsigned int len = 0;

    if (NULL == fast_ap_info) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    int pwd_len = strlen(tuya_password);
    int ssid_len = strlen(tuya_ssid);
    if (ssid_len == 0 || pwd_len == 0) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }
    TAL_PR_DEBUG("wifi_info tuya_password:%s tuya_ssid:%s, pwd_len:%d, ssid_len:%d", tuya_password, tuya_ssid, pwd_len, ssid_len);
    // 计算所需的总内存大小
    int total_len = sizeof(FAST_WF_CONNECTED_AP_INFO_T) + sizeof(int) + ssid_len +  sizeof(int) + pwd_len ;
    FAST_WF_CONNECTED_AP_INFO_T *wifi_info = (FAST_WF_CONNECTED_AP_INFO_T *)malloc(total_len);
    if (wifi_info == NULL) {
        // 处理内存分配失败
        TAL_PR_DEBUG("malloc error");
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }
    // 设置长度
    wifi_info->len = total_len - sizeof(FAST_WF_CONNECTED_AP_INFO_T);
    printf("wifi->len:%d", wifi_info->len);

    char *dest = (char *)wifi_info->data;
    memcpy(dest, &ssid_len, sizeof(int));
    dest += sizeof(int);
    memcpy(dest, tuya_ssid, ssid_len);
    dest += ssid_len;

    memcpy(dest, &pwd_len, sizeof(int));
    dest += sizeof(int);
    memcpy(dest, tuya_password, pwd_len);

//    TAL_PR_DEBUG("wifi_info->len:%d, wifi_info->data:sizeof:%d", wifi_info->len, sizeof(wifi_info->data));
    TAL_PR_DEBUG("Stored SSID: %.*s", ssid_len, wifi_info->data + sizeof(int));
    TAL_PR_DEBUG("Stored PWD: %.*s",  pwd_len, wifi_info->data + sizeof(int) + ssid_len + sizeof(int));
    *fast_ap_info = wifi_info;
    return OPRT_OK;
#endif // 0
    return OPRT_COM_ERROR;
    // --- END: user implements ---
}

/**
 * @brief get wifi bssid
 *
 * @param[out]      mac         uplink mac
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_bssid(UCHAR_T *mac)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_get_bssid");
    puts("tuya_os_adapt_wifi_get_bssid\n");
    unsigned char bssid[6];
    wifi_get_bssid(bssid);
    memcpy(mac, bssid, 6);
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief set wifi country code
 *
 * @param[in]       ccode  country code
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_country_code(CONST COUNTRY_CODE_E ccode)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_set_country_code");
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief do wifi calibration
 *
 * @note called when test wifi
 *
 * @return true on success. faile on failure
 */
OPERATE_RET tkl_wifi_set_rf_calibrated(VOID_T)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_set_rf_calibrated");
    return OPRT_OK;
//    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief set wifi lowpower mode
 *
 * @param[in]       enable      enbale lowpower mode
 * @param[in]       dtim     the wifi dtim
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_lp_mode(CONST BOOL_T enable, CONST UCHAR_T dtim)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_set_lp_mode");
    return OPRT_OK;
    // --- END: user implements ---
}


/**
 * @brief : fast connect
 * @param[in]      fast_ap_info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_fast_connect(CONST FAST_WF_CONNECTED_AP_INFO_T *fast_ap_info)
{
    // --- BEGIN: user implements ---

    TAL_PR_DEBUG("tkl_wifi_station_fast_connect!");
#if 0
    if (NULL == fast_ap_info) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    char *data_ptr = fast_ap_info->data;
    int ssid_len = 0;
    memcpy(&ssid_len, data_ptr, sizeof(int));
    data_ptr += sizeof(int);
    // 读取 SSID 数据
    char ssid[ssid_len + 1];  // +1 for null terminator
    memcpy(ssid, data_ptr, ssid_len);
    ssid[ssid_len] = '\0';  // 添加字符串结束符
    data_ptr += ssid_len;
    // 读取 PWD 长度
    int pwd_len;
    memcpy(&pwd_len, data_ptr, sizeof(int));
    data_ptr += sizeof(int);

    // 读取 PWD 数据
    char pwd[pwd_len + 1];  // +1 for null terminator
    memcpy(pwd, data_ptr, pwd_len);
    pwd[pwd_len] = '\0';  // 添加字符串结束符

    TAL_PR_DEBUG("wifi_info jl_on_ssid:%s jl_on_password:%s", ssid, pwd);

//    tkl_wifi_station_connect(ssid, pwd);
    wifi_enter_sta_mode(ssid, pwd);
    return OPRT_OK;
#endif // 0
    return OPRT_COM_ERROR;
    // --- END: user implements ---
}

/**
 * @brief connect wifi with ssid and passwd
 *
 * @param[in]       ssid
 * @param[in]       passwd
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_connect(CONST SCHAR_T *ssid, CONST SCHAR_T *passwd)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_station_connect!");
    int len = 0;

    int timeout = 0;

    if ((NULL == ssid) || (NULL == passwd)) {
        TAL_PR_DEBUG("tuya_os_adapt_wifi_station_connect : [INVALID PARM]\n");
        return -1;
    }
    enter_ap_mode = 0;
    TAL_PR_DEBUG("tuya_os_adapt_wifi_station_connect :%s [store_mode_save_none=%d]\n", ssid, store_mode_save_none);
#if 1
    if (store_mode_save_none) {

        memset(jl_on_ssid, 0, sizeof(jl_on_ssid));
        len = strlen(ssid);
        len = (len > WIFI_SSID_LEN) ? WIFI_SSID_LEN : len;
        memcpy(jl_on_ssid, ssid, len);

        memset(jl_on_password, 0, sizeof(jl_on_password));
        len = strlen(passwd);
        len = (len > WIFI_PASSWD_LEN) ? WIFI_PASSWD_LEN : len;
        memcpy(jl_on_password, passwd, len);


        TAL_PR_DEBUG("wifi connect **%s**\n", jl_on_ssid);

#if 1
        while (wifi_is_on()) {
            wifi_off();
            while (wifi_is_on()) {
                mdelay(50);
            }
        }
        mdelay(50);
#endif

        if (0 == wifi_is_on()) {
            wifi_set_event_callback(wifi_event_callback);
            wifi_on();
        } else {
            wifi_enter_sta_mode(ssid, passwd);
        }
        request_connect_flag = 1;
    } else {
#endif
        if (strcmp(ssid, jl_on_ssid) == 0  && strcmp(passwd, jl_on_password) == 0 && wf_mode == WWM_STATION) {
            TAL_PR_DEBUG("tuya_os_adapt_wifi_station_connect : [same ssid password]\n");
            request_connect_flag = 1;
            return OPRT_OK;
        }

//        while(first_fast_start_flag == 0){
//             mdelay(1);
//             timeout++;
//             if(timeout > 200)
//                break;
//        }

        memset(jl_on_ssid, 0, sizeof(jl_on_ssid));
        memset(tuya_ssid, 0, sizeof(tuya_ssid));
        len = strlen(ssid);
        len = (len > WIFI_SSID_LEN) ? WIFI_SSID_LEN : len;
        memcpy(jl_on_ssid, ssid, len);
        memcpy(tuya_ssid, ssid, len);


        memset(jl_on_password, 0, sizeof(jl_on_password));
        memset(tuya_password, 0, sizeof(tuya_password));
        len = strlen(passwd);
        len = (len > WIFI_PASSWD_LEN) ? WIFI_PASSWD_LEN : len;
        memcpy(jl_on_password, passwd, len);
        memcpy(tuya_password, passwd, len);

        wifi_enter_sta_mode(ssid, passwd);
    }
    request_connect_flag = 1;
//    wifi_event_cb(WFE_CONNECTED, NULL);
    return OPRT_OK;
//    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief disconnect wifi from connect ap
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_disconnect(VOID_T)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_station_disconnect");
//    wifi_disconnect_station();
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief get wifi connect rssi
 *
 * @param[out]      rssi        the return rssi
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_get_conn_ap_rssi(SCHAR_T *rssi)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_station_get_conn_ap_rssi");
    enum wifi_sta_connect_state  wifi_station_sta;

    wifi_station_sta = wifi_get_sta_connect_state();
    if (wifi_station_sta == WIFI_STA_DISCONNECT || wifi_station_sta == WIFI_STA_CONNECT_TIMEOUT_NOT_FOUND_SSID || wifi_station_sta == WIFI_STA_CONNECT_ASSOCIAT_FAIL || wifi_station_sta == WIFI_STA_CONNECT_ASSOCIAT_TIMEOUT) {
        return OPRT_OS_ADAPTER_COM_ERROR;
    }

    *rssi = (signed char)wifi_get_rssi();
    TAL_PR_DEBUG("tuya_os_adapt_wifi_station_get_conn_ap_rssi:%d!\n", *rssi);
    return OPRT_OK;
//    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief get wifi station work status
 *
 * @param[out]      stat        the wifi station work status
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_get_status(WF_STATION_STAT_E *stat)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_station_get_status!");
    enum wifi_sta_connect_state state;

    state = wifi_get_sta_connect_state();
    TAL_PR_DEBUG("stat:%d", state);
    switch (state) {
    case WIFI_STA_CONNECT_TIMEOUT_NOT_FOUND_SSID :
        *stat = WSS_NO_AP_FOUND;
        break;
    case WIFI_STA_CONNECT_SUCC :
        *stat = WSS_CONN_SUCCESS;
        break;
    case WIFI_STA_NETWORK_STACK_DHCP_SUCC :
        *stat = WSS_GOT_IP;
        break;
    case WIFI_STA_DISCONNECT :
    case WIFI_STA_CONNECT_ASSOCIAT_TIMEOUT :
    case WIFI_STA_CONNECT_ASSOCIAT_FAIL :
    case WIFI_STA_NETWORK_STACK_DHCP_TIMEOUT :
        *stat = WSS_CONN_FAIL;
        break;
    default :
        TAL_PR_DEBUG("tuya_os_adapt_wifi_station_get_status : [NOT DEFAULT]\n");
        break;
    }
    return OPRT_OK;
//    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief send wifi management
 *
 * @param[in]       buf         pointer to buffer
 * @param[in]       len         length of buffer
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_send_mgnt(CONST UCHAR_T *buf, CONST UINT_T len)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("tkl_wifi_send_mgnt");
#if 0
    unsigned short *PktLen = &wifi_send_pkg[0];
    unsigned short *MPDUtotalByteCount = &wifi_send_pkg[10];

    *PktLen = len + 20 + 4 - 8;
    *MPDUtotalByteCount = len;

    memcpy(&wifi_send_pkg[20], buf, len);

    wifi_send_data(wifi_send_pkg, len + 20 + 4, WIFI_TXRATE_1M);
#elif 0

    wifi_send_data(buf, len, WIFI_TXRATE_1M);

#endif
    return OPRT_OK;
//    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief register receive wifi management callback
 *
 * @param[in]       enable
 * @param[in]       recv_cb     receive callback
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_register_recv_mgnt_callback(CONST BOOL_T enable, CONST WIFI_REV_MGNT_CB recv_cb)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("mgnt_set: %d \n", enable);

    if (enable) {
        WF_WK_MD_E mode;
        int ret = tuya_os_adapt_wifi_get_work_mode(&mode);
        if (OPRT_OK != ret) {
            return OPRT_OS_ADAPTER_COM_ERROR;
        }

        if ((mode == WWM_POWERDOWN) || (mode == WWM_SNIFFER)) {
            return OPRT_OS_ADAPTER_COM_ERROR;
        }

        mgnt_recv_cb = recv_cb;

        if (wifi_frame_cb_switch == 0) {
            wifi_frame_cb_switch = 1;
            //wifi_set_frame_cb(wifi_rx_cb);  //注册接收802.11数据帧回调
        }
    } else {
        mgnt_recv_cb = NULL;
        if (sniffer_cb == NULL) {
            wifi_frame_cb_switch = 0;
            //wifi_set_frame_cb(NULL);
        }
    }
    return OPRT_OK;
//    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief wifi ioctl
 *
 * @param[in]       cmd     refer to WF_IOCTL_CMD_E
 * @param[in]       args    args associated with the command
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_ioctl(WF_IOCTL_CMD_E cmd,  VOID *args)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}
