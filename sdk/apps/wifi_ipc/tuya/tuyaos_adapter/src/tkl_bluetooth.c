/**
 * @file tkl_bluetooth.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "tkl_bluetooth.h"
#include "tuya_error_code.h"
#include "tal_log.h"
#include "tuya_ble_sdk.h"
#include "system/includes.h"
#include "uni_log.h"
#include "tuya_bt.h"

#include "le_net_cfg_tuya.h"
//#include "le_net_cfg_tuya.h"

/** 涂鸦接收回调*/
//TY_BT_MSG_CB ty_bt_msg_cb;
static TKL_BLE_GAP_EVT_FUNC_CB tkl_bluetooth_gap_callback;
static TKL_BLE_GATT_EVT_FUNC_CB tkl_bluetooth_gatt_callback;

typedef unsigned char u8;
extern void tuya_bt_send_data(uint16_t uuid,  unsigned char *data, const unsigned char len);
extern void ble_app_disconnect(void);
extern void bt_ble_exit(void);
extern void bt_ble_adv_enable(u8 enable);
extern int tuya_set_adv_data(unsigned char *data, unsigned int len);
extern int tuya_set_rsp_data(unsigned char *data, unsigned int len);
extern void bt_ble_module_init(void);
static bool ble_init = false;
static tuya_bt_not_allowed_init = false;

#define BLE_CONN_HANDLE			0x0001

void tuya_ble_gap_cb(int status)
{
    TKL_BLE_GAP_PARAMS_EVT_T event;
    memset(&event, 0, SIZEOF(TKL_BLE_GAP_PARAMS_EVT_T));

    if (0 == status) {
        PR_INFO("venz: ble connected ......");
        event.type = TKL_BLE_GAP_EVT_CONNECT;
    } else if (1 == status) {
        PR_INFO("venz: ble disconnect ......");
        event.type = TKL_BLE_GAP_EVT_DISCONNECT;
    } else if (2 == status) {
        PR_INFO("venz: ble stack init ......");
        event.type = TKL_BLE_EVT_STACK_INIT;
    } else {
        PR_INFO("venz: ble status error!");
    }

    event.conn_handle = BLE_CONN_HANDLE;
    event.gap_event.connect.role = TKL_BLE_ROLE_SERVER;

    if (tkl_bluetooth_gap_callback) {
        tkl_bluetooth_gap_callback(&event);
    }
}

void tuya_ble_gatt_cb(UINT16_T uuid, UINT8_T *data, UINT8_T len)
{
    //BLE_CACHE_DATA_T *cache_data = NULL;

    TKL_BLE_GATT_PARAMS_EVT_T event;
    memset(&event, 0, SIZEOF(TKL_BLE_GATT_PARAMS_EVT_T));
//    memset(gatt_event_data, 0, 32);
#if 0
    cache_data = (BLE_CACHE_DATA_T *)Malloc(SIZEOF(BLE_CACHE_DATA_T) + len);
    if (!cache_data) {
        PR_ERR("Malloc err");
        return;
    } else {
        cache_data->uuid = uuid;
        cache_data->length = len;
        memcpy(cache_data->data, data, len);
    }
#endif

    PR_INFO("ty_ble_gatt_cb ......");
    for (int i = 0; i < len; i++) {
        PR_DEBUG_RAW(" %02x", data[i]);
    }
    PR_DEBUG_RAW("\r\n");
    //memcpy(gatt_event_data, data, len);

    event.result = 0;
    event.type = TKL_BLE_GATT_EVT_WRITE_REQ;
    event.conn_handle = BLE_CONN_HANDLE;
    event.gatt_event.write_report.char_handle = uuid; //uuid;
    event.gatt_event.write_report.report.length = len;
#if 0
    //event.gatt_event.write_report.report.p_data = data;
    event.gatt_event.write_report.report.p_data = gatt_event_data;
#else
    event.gatt_event.write_report.report.p_data = malloc(len);
    memcpy(event.gatt_event.write_report.report.p_data, data, len);
#endif
    if (tkl_bluetooth_gatt_callback) {
        PR_INFO("rokid_ble_gatt_cb:  uuid: 0x%04x; len: %d.", uuid, len);
        for (int i = 0; i < len; i++) {
            PR_DEBUG_RAW(" %02x", event.gatt_event.write_report.report.p_data[i]);
        }
        PR_DEBUG_RAW("\r\n");
        tkl_bluetooth_gatt_callback(&event);
    }
    free(event.gatt_event.write_report.report.p_data);
}


void tuya_bt_state_connected(void)
{
    tuya_ble_gap_cb(0);
}

void tuya_bt_state_disconnected(void)
{
    tuya_ble_gap_cb(1);
}

void tuya_bt_state_init(void)
{
    tuya_ble_gap_cb(2);
}

void tuya_ble_write_callback(unsigned short uuid, unsigned char *buf, unsigned short buf_size)
{
    tuya_ble_gatt_cb(uuid, buf, buf_size);
}

// --- END: user defines and implements ---

/**
 * @brief   Function for initializing the ble stack
 * @param   role                Indicate the role for ble stack.
 *                              role = 1: ble peripheral    @TKL_BLE_ROLE_SERVER
 *                              role = 2: ble central       @TKL_BLE_ROLE_CLIENT
 * @return  SUCCESS             Initialized successfully.
 *          ERROR
 * */
OPERATE_RET tkl_ble_stack_init(UCHAR_T role)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("into tkl_ble_stack_init");

    /** 初始化蓝牙模块*/
    if (!ble_init) {
        bt_ble_module_init();
    }
    tuya_bt_state_init();
    ble_init = true;

//    int ret;
//    ret = tuya_iot_wf_gw_reset();
//    if(ret != OPRT_OK)
//    {
//        TAL_PR_ERR("ret:%d", ret);
//    }
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Function for de-initializing the ble stack features
 * @param   role                 Indicate the role for ble stack.
 *                               role = 1: ble peripheral
 *                               role = 2: ble central
 * @return  SUCCESS             Deinitialized successfully.
 *          ERROR
 * */
OPERATE_RET tkl_ble_stack_deinit(UCHAR_T role)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("into tkl_ble_stack_deinit");
    if (!ble_init) {
        return OPRT_OK;
    }
    printf("tuya_os_adapt_bt_port_deinit");

    /** 关闭蓝牙模块*/
    bt_ble_exit();

    ble_init = false;

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Function for getting the GATT Link-Support.
 * @param   p_link              return gatt link
 * @return  SUCCESS             Support Gatt Link
 *          ERROR               Only Beacon or Mesh Beacon, Not Support Gatt Link.
 * */
OPERATE_RET tkl_ble_stack_gatt_link(USHORT_T *p_link)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("into tkl_ble_stack_gatt_link");
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Register GAP Event Callback
 * @param   TKL_BLE_GAP_EVT_FUNC_CB Refer to @TKL_BLE_GAP_EVT_FUNC_CB
 * @return  SUCCESS         Register successfully.
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_callback_register(CONST TKL_BLE_GAP_EVT_FUNC_CB gap_evt)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("into tkl_ble_gap_callback_register");
    tkl_bluetooth_gap_callback = gap_evt;
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Register GATT Event Callback
 * @param   TKL_BLE_GATT_EVT_FUNC_CB Refer to @TKL_BLE_GATT_EVT_FUNC_CB
 * @return  SUCCESS         Register successfully.
 *          ERROR
 * */
OPERATE_RET tkl_ble_gatt_callback_register(CONST TKL_BLE_GATT_EVT_FUNC_CB gatt_evt)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("into tkl_ble_gatt_callback_register");
    tkl_bluetooth_gatt_callback = gatt_evt;
    return OPRT_OK;
    // --- END: user implements ---
}

/******************************************************************************************************************************/
/** @brief Define All GAP Interface
 */
/**
 * @brief   Set the local Bluetooth identity address.
 *          The local Bluetooth identity address is the address that identifies this device to other peers.
 *          The address type must be either @ref TKL_BLE_GAP_ADDR_TYPE_PUBLIC or @ref TKL_BLE_GAP_ADDR_TYPE_RANDOM.
 * @param   [in] p_peer_addr:   pointer to local address parameters
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_addr_set(TKL_BLE_GAP_ADDR_T CONST *p_peer_addr)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("into tkl_ble_gap_addr_set");
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Get the local Bluetooth identity address.
 * @param   [out] p_peer_addr:  pointer to local address
 * @return  SUCCESS             Set Address successfully.
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_address_get(TKL_BLE_GAP_ADDR_T *p_peer_addr)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("into tkl_ble_gap_address_get");
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Start advertising
 * @param   [in] p_adv_params : pointer to advertising parameters
 * @return  SUCCESS
 *  ERROR
 * */
OPERATE_RET tkl_ble_gap_adv_start(TKL_BLE_GAP_ADV_PARAMS_T CONST *p_adv_params)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("into tkl_ble_gap_adv_start");
    if (!ble_init) {
        return OPRT_OK;
    }
    bt_ble_adv_enable(1);
    TAL_PR_DEBUG("exit tkl_ble_gap_adv_start!");
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Stop advertising
 * @param   VOID
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_adv_stop(VOID)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("into tkl_ble_gap_adv_stop");
    if (!ble_init) {
        return OPRT_OK;
    }
    bt_ble_adv_enable(0);
    TAL_PR_DEBUG("exit tkl_ble_gap_adv_stop!");
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Setting advertising data
 * @param   [in] p_adv:         Data to be used in advertisement packets, and include adv data len
 *          [in] p_scan_rsp:    Data to be used in advertisement respond packets, and include rsp data len
 * @Note    Please Check p_adv and p_scan_rsp, if data->p_data == NULL or data->length == 0, we will not update these values.
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_adv_rsp_data_set(TKL_BLE_DATA_T CONST *p_adv, TKL_BLE_DATA_T CONST *p_scan_rsp)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("into tkl_ble_gap_adv_rsp_data_set");
    if (!ble_init) {
        return OPRT_OK;
    }
    printf("tuya_os_adapt_bt_reset_adv");
    put_buf(p_adv->p_data, p_adv->length);
    put_buf(p_scan_rsp->p_data, p_scan_rsp->length);
    /** 关闭广播*/
    bt_ble_adv_enable(0);

    /** 设置adv data*/
    tuya_set_adv_data(p_adv->p_data, p_adv->length);

    /** 设置rsp data*/
    tuya_set_rsp_data(p_scan_rsp->p_data, p_scan_rsp->length);

    /** 打开广播*/
    bt_ble_adv_enable(1);

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Update advertising data
 * @param   [in] p_adv: Data    to be used in advertisement packets, and include adv data len
 *          [in] p_scan_rsp:    Data to be used in advertisement respond packets, and include rsp data len
 * @Note    Please Check p_adv and p_scan_rsp, if data->p_data == NULL or data->length == 0, we will not update these values.
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_adv_rsp_data_update(TKL_BLE_DATA_T CONST *p_adv, TKL_BLE_DATA_T CONST *p_scan_rsp)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("into tkl_ble_gap_adv_rsp_data_update");
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Create extended advertising
 * @param   [in] p_ext_adv:     extended advertising handle
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_ext_adv_create(TKL_BLE_GAP_EXT_ADV_T *p_ext_adv)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("into tkl_ble_gap_ext_adv_create");
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Config extended advertising
 * @param   [in] p_ext_adv:     extended advertising handle
 *          [in] p_adv_params:  pointer to advertising parameters
 *          [in] p_adv:         Data to be used in advertisement packets, and include adv data len
 *          [in] p_scan_rsp:    Data to be used in advertisement respond packets, and include rsp data len
 * @Note    Please Check p_adv and p_scan_rsp, if data->p_data == NULL or data->length == 0, we will not update these values.
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_ext_adv_config(TKL_BLE_GAP_EXT_ADV_T ext_adv, TKL_BLE_GAP_EXT_ADV_PARAMS_T CONST *p_adv_params,
                                       TKL_BLE_DATA_T CONST *p_adv_data, TKL_BLE_DATA_T CONST *p_scan_rsp)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("into tkl_ble_gap_ext_adv_config");
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Start extended advertising
 * @param   [in] p_ext_adv:     extended advertising handle
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_ext_adv_start(TKL_BLE_GAP_EXT_ADV_T ext_adv)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("into tkl_ble_gap_ext_adv_start");
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Stop extended advertising
 * @param   [in] p_ext_adv:     extended advertising handle
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_ext_adv_stop(TKL_BLE_GAP_EXT_ADV_T ext_adv)
{
    // --- BEGIN: user implements ---
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Delete extended advertising
 * @param   [in] p_ext_adv:     extended advertising handle
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_ext_adv_delete(TKL_BLE_GAP_EXT_ADV_T ext_adv)
{
    // --- BEGIN: user implements ---
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Clear all extended advertising
 * @param   VOID
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_ext_adv_clear(void)
{
    // --- BEGIN: user implements ---
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Query the max data length of extended advertising supported by the controller
 * @param   VOID
 * @return  SUCCESS
 *          ERROR
 * */
uint16_t  tkl_ble_gap_ext_adv_get_max_data_length(void)
{
    // --- BEGIN: user implements ---
    return 0;
    // --- END: user implements ---
}

/**
 * @brief   Query the max number of extended advertising supported by the controller
 * @param   VOID
 * @return  SUCCESS
 *          ERROR
 * */
uint8_t tkl_ble_gap_ext_adv_get_support_number(void)
{
    // --- BEGIN: user implements ---
    return 0;
    // --- END: user implements ---
}

/**
 * @brief   Start scanning
 * @param   [in] scan_param:    scan parameters including interval, windows
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_scan_start(TKL_BLE_GAP_SCAN_PARAMS_T CONST *p_scan_params)
{
    // --- BEGIN: user implements ---
    TAL_PR_DEBUG("into tkl_ble_gap_scan_start");
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Stop scanning
 * @param   VOID
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_scan_stop(VOID)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gap_scan_stop");

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Start connecting one peer
 * @param   [in] p_peer_addr:   include address and address type
 *          [in] p_scan_params: scan parameters
 *          [in] p_conn_params: connection  parameters
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_connect(TKL_BLE_GAP_ADDR_T CONST *p_peer_addr, TKL_BLE_GAP_SCAN_PARAMS_T CONST *p_scan_params, TKL_BLE_GAP_CONN_PARAMS_T CONST *p_conn_params)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gap_connect");

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Disconnect from peer
 * @param   [in] conn_handle:   the connection handle
 *          [in] hci_reason:    terminate reason
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_disconnect(USHORT_T conn_handle, UCHAR_T hci_reason)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gap_disconnect");
    if (!ble_init) {
        return OPRT_OK;
    }
    printf("tuya_os_adapt_bt_gap_disconnect");

    /** 断开蓝牙连接*/
    ble_app_disconnect();

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Start to update connection parameters
 * @param   [in] conn_handle:   connection handle
 *          [in] p_conn_params: connection  parameters
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_conn_param_update(USHORT_T conn_handle, TKL_BLE_GAP_CONN_PARAMS_T CONST *p_conn_params)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gap_conn_param_update");

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Set the radio's transmit power.
 * @param   [in] role:          0: Advertising Tx Power; 1: Scan Tx Power; 2: Connection Power
 *          [in] tx_power:      tx power:This value will be magnified 10 times.
 *                              If the tx_power value is -75, the real power is -7.5dB.(or 40 = 4dB)
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_tx_power_set(UCHAR_T role, INT_T tx_power)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gap_tx_power_set");

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Get the received signal strength for the last connection event.
 * @param   [in]conn_handle:    connection handle
 * @return  SUCCESS             Successfully read the RSSI.
 *          ERROR               No sample is available.
 * */
OPERATE_RET tkl_ble_gap_rssi_get(USHORT_T conn_handle)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gap_rssi_get");
    ble_vendor_get_peer_rssi(conn_handle);
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Set the GAP Name For Bluetooth
 * @param   [in]p_name:         GAP Name String
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gap_name_set(CHAR_T *p_name)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gap_name_set");
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Add Ble Gatt Service
 * @param   [in] p_service: define the ble service
 *
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gatts_service_add(TKL_BLE_GATTS_PARAMS_T *p_service)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gatts_service_add");
    INT_T i = 0, j = 0;
    UINT8_T svc_num = 0;

    svc_num = p_service->svc_num;

    for (i = 0; i < svc_num; i++) {
        /* Service Information */
        TKL_BLE_SERVICE_PARAMS_T *p_service_param = &p_service->p_service[i];
        /* Characteristic information*/
        UINT8_T chr_num = p_service_param->char_num;
        for (j = 0; j < chr_num; j++) {
            p_service_param->p_char[j].handle = ATT_CHARACTERISTIC_00000001_0000_1001_8001_00805F9B07D0_01_VALUE_HANDLE;
        }
    }
    return OPRT_OK;
//    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief   [Optional] Indicates a change in attribute assignment to all subscribed peers(Specify conn_handle).
 *
 * @param   [in] conn_handle    Connection handle.
 * @param   [in] start_handle   The start of the affected handle range.
 * @param   [in] end_handle     The end of the affected handle range.
 *
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gatts_service_change(USHORT_T conn_handle, USHORT_T start_handle, USHORT_T end_handle)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gatts_service_change");
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Set the value of a given attribute. After Config Tuya Read-Char, we can update read-value at any time.
 * @param   [in] conn_handle    Connection handle.
 *          [in] char_handle    Attribute handle.
 *          [in,out] p_value    Attribute value information.
 * @return  SUCCESS
 *          ERROR
 *
 * @note Values other than system attributes can be set at any time, regardless of whether any active connections exist.
 * */
OPERATE_RET tkl_ble_gatts_value_set(USHORT_T conn_handle, USHORT_T char_handle, UCHAR_T *p_data, USHORT_T length)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gatts_value_set");
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Get the value of a given attribute.
 * @param   [in] conn_handle    Connection handle. Ignored if the value does not belong to a system attribute.
 * @param   [in] char_handle    Attribute handle.
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gatts_value_get(USHORT_T conn_handle, USHORT_T char_handle, UCHAR_T *p_data, USHORT_T length)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gatts_value_set");

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Notify an attribute value.
 * @param   [in] conn_handle    Connection handle.
 * @param   [in] char_handle    Attribute handle.
 *          [in] p_data         Notify Values
 *          [in] length         Value Length
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gatts_value_notify(USHORT_T conn_handle, USHORT_T char_handle, UCHAR_T *p_data, USHORT_T length)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gatts_value_notify, chr_handle: 0x%04x", char_handle);
    if (!ble_init) {
        TAL_PR_DEBUG("bt_stack close,bt operation invalid.\n");
        return OPRT_OK;
    }

    if (0 == length || NULL == p_data) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    tuya_bt_send_data(char_handle, p_data, length);
    PR_INFO("`--->BLE-TX`", p_data, length);
    return OPRT_OK;
//    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief   Indicate an attribute value.
 * @param   [in] conn_handle    Connection handle.
 * @param   [in] char_handle    Attribute handle.
 *          [in] p_data         Notify Values
 *          [in] length         Value Length
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gatts_value_indicate(USHORT_T conn_handle, USHORT_T char_handle, UCHAR_T *p_data, USHORT_T length)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gatts_value_indicate");

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Reply to an ATT_MTU exchange request by sending an Exchange MTU Response to the client.
 * @param   [in] conn_handle    Connection handle.
 *          [in] server_rx_mtu  mtu size.
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gatts_exchange_mtu_reply(USHORT_T conn_handle, USHORT_T server_rx_mtu)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gatts_exchange_mtu_reply");

    return OPRT_OK;
    // --- END: user implements ---
}

/******************************************************************************************************************************/
/** @brief Define All Gatt Client Interface, Refer to current ble gw and ble stack.
 *
 *  Notes: notice the handle will be the one of signed point.
 *  Discovery Operations belongs to GAP Interface, But declear here, because it will be used for the gatt client.
 */

/**
 * @brief   [Ble Central] Will Discovery All Service
 * @param   [in] conn_handle    Connection handle.
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gattc_all_service_discovery(USHORT_T conn_handle)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gattc_all_service_discovery");

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   [Ble Central] Will Discovery All Characteristic
 * @param   [in] conn_handle    Connection handle.
 *          [in] start_handle   Handle of start
 *          [in] end_handle     Handle of End
 * @return  SUCCESS
 *          ERROR
 * @Note:   For Tuya Service, it may contains more optional service, it is more better to find all Characteristic
 *          instead of find specific uuid.
 * */
OPERATE_RET tkl_ble_gattc_all_char_discovery(USHORT_T conn_handle, USHORT_T start_handle, USHORT_T end_handle)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gattc_all_char_discovery");

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   [Ble Central] Will Discovery All Descriptor of Characteristic
 * @param   [in] conn_handle    Connection handle.
 * @param   [in] conn_handle    Connection handle.
 *          [in] start_handle   Handle of start
 *          [in] end_handle     Handle of End
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gattc_char_desc_discovery(USHORT_T conn_handle, USHORT_T start_handle, USHORT_T end_handle)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gattc_char_desc_discovery");

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   [Ble Central] Write Data without Response
 * @param   [in] conn_handle    Connection handle.
 * @param   [in] char_handle    Attribute handle.
 *          [in] p_data         Write Values
 *          [in] length         Value Length
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gattc_write_without_rsp(USHORT_T conn_handle, USHORT_T char_handle, UCHAR_T *p_data, USHORT_T length)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gattc_write_without_rsp");

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   [Ble Central] Write Data with response
 * @param   [in] conn_handle    Connection handle.
 * @param   [in] char_handle    Attribute handle.
 *          [in] p_data         Write Values
 *          [in] length         Value Length
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gattc_write(USHORT_T conn_handle, USHORT_T char_handle, UCHAR_T *p_data, USHORT_T length)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gattc_write");

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   [Ble Central] Read Data
 * @param   [in] conn_handle    Connection handle.
 * @param   [in] char_handle    Attribute handle.
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gattc_read(USHORT_T conn_handle, USHORT_T char_handle)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gattc_read");

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   Start an ATT_MTU exchange by sending an Exchange MTU Request to the server.
 * @param   [in] conn_handle    Connection handle.
 *          [in] client_rx_mtu  mtu size.
 * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_gattc_exchange_mtu_request(USHORT_T conn_handle, USHORT_T client_rx_mtu)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_gattc_exchange_mtu_request");

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief   [Special Command Control] Base on Bluetooth, We can do some special commands for exchanging some informations.
 * @param   [in] opcode         Operations Opcode.
 *          [in] user_data      Post Some Special Commands Data.
 *          [in] data_len       User's Data Length.
 * @note    For Operations Codes, we can do anythings after exchange from TAL Application
 *          And We define some Opcodes as below for reference.
 *          For Bluetooth NCP Module: Mask=0x01, Code ID: 0x00~0xff. Opcode = ((0x01 << 8) & Code ID)
 *          eg:     0x0100: Special Vendor Module Init
 *                  0x0101: Special Vendor Module Deinit
 *                  0x0102: Special Vendor Module Reset
 *                  0x0103: Special Vendor Module Check Exist: Return OPRT_OK or OPRT_NOT_FOUND ..
 *                  0x0104: Specail Vendor Module Version Get.
 *                  0x0105: Specail Vendor Module Version Set.
 *                  0x0106: Specail Vendor Module Version Update.
 *                  0x0107: Specail Vendor Module Scan Switch.
 *                  0x0108: Specail Vendor Module Scan Stop.
 *                  0x0109: Specail Vendor Module Auth Check.
 *                  0x0110: Specail Vendor Module Auth Erase.
 *
 *  * @return  SUCCESS
 *          ERROR
 * */
OPERATE_RET tkl_ble_vendor_command_control(USHORT_T opcode, VOID_T *user_data, USHORT_T data_len)
{
    // --- BEGIN: user implements ---
    PR_INFO("tkl_ble_vendor_command_control");

    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief set ble mode, used in wifi ble coexist mode
 *
 * @param[in]       enable     enbale mode
 * @param[in]       mode       the ble mode
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_ble_set_mode(CONST BOOL_T enable, CONST UCHAR_T mode)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

