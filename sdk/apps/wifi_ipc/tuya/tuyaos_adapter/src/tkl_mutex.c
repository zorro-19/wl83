/**
 * @file tkl_mutex.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "tkl_mutex.h"
#include "tuya_error_code.h"
#include "os_api.h"
//#include "FreeRTOSConfig.h"


typedef struct {
    OS_MUTEX  mutex;
} MUTEX_MANAGE, *P_MUTEX_MANAGE;
// --- END: user defines and implements ---

/**
* @brief Create mutex
*
* @param[out] pMutexHandle: mutex handle
*
* @note This API is used to create and init a recursive mutex.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_mutex_create_init(TKL_MUTEX_HANDLE *pMutexHandle)
{
    // --- BEGIN: user implements ---
//    printf("创建mutex！");
#if 0
    if (!pMutexHandle) {
        return OPRT_INVALID_PARM;
    }

    P_MUTEX_MANAGE pMutexManage;
    pMutexManage = (P_MUTEX_MANAGE)malloc(sizeof(MUTEX_MANAGE));
    if (!(pMutexManage)) {
        return OPRT_OS_ADAPTER_MALLOC_FAILED;
    }
    if (0 != os_mutex_create(&pMutexManage->mutex)) {
        return OPRT_OS_ADAPTER_MUTEX_CREAT_FAILED;
    }

    *pMutexHandle = (TKL_MUTEX_HANDLE)pMutexManage;
#endif // 0

#if 1
    if (pMutexHandle == NULL) {
        return OPRT_INVALID_PARM;
    }

    OS_MUTEX *mutex = (OS_MUTEX *)malloc(sizeof(OS_MUTEX));
    if (mutex == NULL) {
        return OPRT_OS_ADAPTER_MALLOC_FAILED;
    }

    int ret = os_mutex_create(mutex);
    if (ret != 0) {
        free(mutex);
        return (OPERATE_RET)ret;
    }

    *pMutexHandle = (VOID_T *)mutex;
    return OPRT_OK;
#endif // 1

//    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief Lock mutex
*
* @param[in] mutexHandle: mutex handle
*
* @note This API is used to lock a recursive mutex.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_mutex_lock(CONST TKL_MUTEX_HANDLE mutexHandle)
{
    // --- BEGIN: user implements ---
    // if(!mutexHandle) {
    //     return OPRT_INVALID_PARM;
    // }

    // BaseType_t ret;
    // ret = xSemaphoreTakeRecursive(mutexHandle, portMAX_DELAY);
    // if (pdTRUE != ret) {
    //     return OPRT_OS_ADAPTER_MUTEX_LOCK_FAILED;
    // }
//    int ret;
//    ret = os_mutex_pend(mutexHandle, 0);
//    if (0 != ret) {
//        return OPRT_OS_ADAPTER_MUTEX_LOCK_FAILED;
//    }
//    printf("tkl_mutex_lock");
#if 0
    if (!mutexHandle) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    P_MUTEX_MANAGE pMutexManage;
    pMutexManage = (P_MUTEX_MANAGE)mutexHandle;
    int ret;
    // ret = xSemaphoreTake(pMutexManage->mutex, portMAX_DELAY);
    ret = os_mutex_pend(&pMutexManage->mutex, 0);
    if (0 != ret) {
        return OPRT_OS_ADAPTER_MUTEX_LOCK_FAILED;
    }
#endif // 0

#if 1
    if (mutexHandle == NULL) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    OS_MUTEX *mutex = (OS_MUTEX *)mutexHandle;
    int ret = os_mutex_pend(mutex, 0);
    if (ret != 0) {
        return (OPERATE_RET)ret;
    }

    return OPRT_OK;

#endif // 1

//    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief Try Lock mutex
*
* @param[in] mutexHandle: mutex handle
*
* @note This API is used to try lock a recursive mutex.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_mutex_trylock(CONST TKL_MUTEX_HANDLE mutexHandle)
{
    // --- BEGIN: user implements ---
//    INT_T ret;
//    ret = os_mutex_accept(mutexHandle);
//    if(ret != 0) {
//        return OPRT_OS_ADAPTER_MUTEX_LOCK_FAILED;
//    }
//    printf("tkl_mutex_trylock");
#if 0
    if (!mutexHandle) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    P_MUTEX_MANAGE pMutexManage;
    pMutexManage = (P_MUTEX_MANAGE)mutexHandle;
    int ret;
    ret = os_mutex_accept(&pMutexManage->mutex);
    if (0 != ret) {
        return OPRT_OS_ADAPTER_MUTEX_LOCK_FAILED;
    }
#endif // 0

#if 1
    if (mutexHandle == NULL) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    OS_MUTEX *mutex = (OS_MUTEX *)mutexHandle;
    int ret = os_mutex_accept(mutex);
    if (ret != 0) {
        return (OPERATE_RET)ret;
    }

    return OPRT_OK;
#endif // 1
//    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief Unlock mutex
*
* @param[in] mutexHandle: mutex handle
*
* @note This API is used to unlock a recursive mutex.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_mutex_unlock(CONST TKL_MUTEX_HANDLE mutexHandle)
{
    // --- BEGIN: user implements ---
    // BaseType_t ret;

    // if(!mutexHandle) {
    //     return OPRT_INVALID_PARM;
    // }

    // ret = xSemaphoreGiveRecursive(mutexHandle);
    // if (pdTRUE != ret) {
    //     return OPRT_OS_ADAPTER_MUTEX_UNLOCK_FAILED;
    // }
//    printf("tkl_mutex_trylock");
#if 0
    if (!mutexHandle) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    P_MUTEX_MANAGE pMutexManage;
    pMutexManage = (P_MUTEX_MANAGE)mutexHandle;

    int ret;
    ret = os_mutex_post(&pMutexManage->mutex); //释放互斥量
    if (0 != ret) {
        return OPRT_OS_ADAPTER_MUTEX_UNLOCK_FAILED;
    }
#endif // 0

#if 1
    if (mutexHandle == NULL) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    OS_MUTEX *mutex = (OS_MUTEX *)mutexHandle;
    int ret = os_mutex_post(mutex);
    if (ret != 0) {
        return (OPERATE_RET)ret;
    }

    return OPRT_OK;

#endif // 1

//    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief Release mutex
*
* @param[in] mutexHandle: mutex handle
*
* @note This API is used to release a recursive mutex.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_mutex_release(CONST TKL_MUTEX_HANDLE mutexHandle)
{
    // --- BEGIN: user implements ---
//    printf("tkl_mutex_release");
#if 0
    if (!mutexHandle) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    P_MUTEX_MANAGE pMutexManage;
    pMutexManage = (P_MUTEX_MANAGE)mutexHandle;

    // vSemaphoreDelete(pMutexManage->mutex);
    os_mutex_del(&pMutexManage->mutex, OS_DEL_ALWAYS);
//    os_mutex_free(pMutexManage->mutex);
    tkl_system_free(mutexHandle);
#endif // 0

#if 1
    if (mutexHandle == NULL) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    OS_MUTEX *mutex = (OS_MUTEX *)mutexHandle;
    int ret = os_mutex_del(mutex, OS_DEL_ALWAYS);
    if (ret != 0) {
        return (OPERATE_RET)ret;
    }

    free(mutex);
    return OPRT_OK;
#endif // 1

//    return OPRT_OK;
    // --- END: user implements ---
}

