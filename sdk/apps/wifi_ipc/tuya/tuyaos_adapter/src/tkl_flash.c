/**
 * @file tkl_flash.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "tkl_flash.h"
#include "tuya_error_code.h"
#include "device/ioctl_cmds.h"
#include "tkl_mutex.h"
#include "board_config.h"
#include "app_config.h"
#include "tal_log.h"
#include "system/includes.h"
#include "fs/fs.h"
#include "asm/sfc_norflash_api.h"
// --- END: user defines and implements ---
static TKL_MUTEX_HANDLE  flash_mutex = NULL;

//44c000--433000
// UF_PARTITION_START      60k         433000 ------ 442000
// SIMPLE_FLASH_KEY_ADDR   4k          442000 ------ 443000
// SIMPLE_FLASH_START      32k         443000 ------ 44B000   KV数据区
// PROTECTED_DATA_ADDR     4k          44B000 ------ 44C000

//  ((__FLASH_SIZE__) - (CONFIG_UI_PACKRES_LEN) - 0x1000 - CONFIG_AUDIO_PACKRES_LEN - CONFIG_LOGO_PACKRES_LEN)

#define PARTITION_SIZE         (1 << 12) // 4KB
#define FLH_BLOCK_SZ            PARTITION_SIZE

//#define SIMPLE_FLASH_KEY_ADDR  0x442000            //KEY 4k

//#define SIMPLE_FLASH_START     0x443000
#define SIMPLE_FLASH_SIZE      0x8000                // KV 32k

//#define UF_PARTITION_START     0x433000
#define UF_PARTITION_SIZE      0xF000              //UF 60k

#if defined(KV_PROTECTED_ENABLE) && (KV_PROTECTED_ENABLE==1)
//   #define PROTECTED_DATA_ADDR     0x44B000 // protected data (1 block)
#define PROTECTED_FLASH_HUGE_SZ 0x1000 // 4k  不共基的块大小
#endif

#define tuya_space_path "mnt/sdfile/EXT_RESERVED/tuya"

static u32 get_flash_exif_addr(void)
{
    u32 addr;
    FILE *profile_fp = fopen(tuya_space_path, "r");
    if (profile_fp == NULL) {
        puts("user_get_flash_addr ERROR!!!\r\n");
        return 0;
    }
    struct vfs_attr file_attr;
    fget_attrs(profile_fp, &file_attr);
    addr = sdfile_cpu_addr2flash_addr(file_attr.sclust);
    fclose(profile_fp);

    /* printf("user_get_flash_exif_addr = 0x%x, size = 0x%x \r\n", addr, file_attr.fsize); */
    return addr;
}

/**
* @brief read flash
*
* @param[in] addr: flash address
* @param[out] dst: pointer of buffer
* @param[in] size: size of buffer
*
* @note This API is used for reading flash.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_flash_read(UINT32_T addr, UCHAR_T *dst, UINT32_T size)
{
    // --- BEGIN: user implements ---
    int ret = OPRT_OK;

    if (NULL == dst) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if (NULL == flash_mutex) {
        ret = tkl_mutex_create_init(&flash_mutex);
        if (ret != OPRT_OK) {
            return ret;
        }
    }

    tkl_mutex_lock(flash_mutex);

    ret = norflash_open(NULL, NULL, NULL);

    ret = norflash_origin_read(dst, addr, size);

    tkl_mutex_unlock(flash_mutex);

    return OPRT_OK;
    // return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
* @brief write flash
*
* @param[in] addr: flash address
* @param[in] src: pointer of buffer
* @param[in] size: size of buffer
*
* @note This API is used for writing flash.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_flash_write(UINT32_T addr, CONST UCHAR_T *src, UINT32_T size)
{
    int ret ;

    if (NULL == src) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if (NULL == flash_mutex) {
        ret = tkl_mutex_create_init(&flash_mutex);
        if (ret != OPRT_OK) {
            return ret;
        }
    }
    tkl_mutex_lock(flash_mutex);

    ret = norflash_open(NULL, NULL, NULL);

    ret = norflash_ioctl(NULL, IOCTL_SET_WRITE_PROTECT, 0);

    ret = norflash_write(NULL, src, size, addr);

    tkl_mutex_unlock(flash_mutex);
//    printf("flash write exit!");
    return OPRT_OK;
    // --- BEGIN: user implements ---
    // return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
* @brief erase flash
*
* @param[in] addr: flash address
* @param[in] size: size of flash block
*
* @note This API is used for erasing flash.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_flash_erase(UINT32_T addr, UINT32_T size)
{
    int ret ;
//    printf("flash erase addr:0x%x, size: %d!", addr, size);

#define FLASH_BLOCK 4096
    ret = norflash_open(NULL, NULL, NULL);

    int beginBlock = (addr / FLASH_BLOCK);
    int endBlock = (((addr + size) / FLASH_BLOCK));

    int writeLength = 0;
    int length = FLASH_BLOCK - (addr % FLASH_BLOCK);

    ret = norflash_ioctl(NULL, IOCTL_SET_WRITE_PROTECT, 0);

    if (length >= size) {
        ret = norflash_ioctl(NULL, IOCTL_ERASE_SECTOR, beginBlock * FLASH_BLOCK);//每个块，写之前擦除对应块
        return 0;
    } else {
        ret = norflash_ioctl(NULL, IOCTL_ERASE_SECTOR, beginBlock * FLASH_BLOCK);//每个块，写之前擦除对应块
        writeLength = length;
    }

    for (int i = beginBlock + 1; i < endBlock; i++) {
        ret = norflash_ioctl(NULL, IOCTL_ERASE_SECTOR, i * FLASH_BLOCK);
        ret = norflash_ioctl(NULL, IOCTL_ERASE_SECTOR, i * FLASH_BLOCK);
        writeLength += FLASH_BLOCK;
    }

    if (beginBlock != endBlock && (size > writeLength)) {
        ret = norflash_ioctl(NULL, IOCTL_ERASE_SECTOR, endBlock * FLASH_BLOCK);
    }


//    printf("tkl_flash_erase exit");
    return OPRT_OK;
    // --- BEGIN: user implements ---
    // return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
* @brief lock flash
*
* @param[in] addr: lock begin addr
* @param[in] size: lock area size
*
* @note This API is used for lock flash.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_flash_lock(UINT32_T addr, UINT32_T size)
{
    // --- BEGIN: user implements ---
//    printf("flash lock!");
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
* @brief unlock flash
*
* @param[in] addr: unlock begin addr
* @param[in] size: unlock area size
*
* @note This API is used for unlock flash.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_flash_unlock(UINT32_T addr, UINT32_T size)
{
    // --- BEGIN: user implements ---
//    printf("flash unlock");
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
* @brief get flash information
*
* @param[out] info: the description of the flash
*
* @note This API is used to get description of storage.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_flash_get_one_type_info(TUYA_FLASH_TYPE_E type, TUYA_FLASH_BASE_INFO_T *info)
{
    // --- BEGIN: user implements ---
//    printf("tkl_flash_get_one_type_info, type:%d", type);
    if ((type > TUYA_FLASH_TYPE_MAX) || (info == NULL)) {
        return OPRT_INVALID_PARM;
    }

    unsigned int UF_PARTITION_START = get_flash_exif_addr();
    unsigned int SIMPLE_FLASH_KEY_ADDR = UF_PARTITION_START + UF_PARTITION_SIZE;
    unsigned int SIMPLE_FLASH_START = SIMPLE_FLASH_KEY_ADDR + FLH_BLOCK_SZ;
    unsigned int PROTECTED_DATA_ADDR = SIMPLE_FLASH_START + SIMPLE_FLASH_SIZE;

    switch (type) {
    case TUYA_FLASH_TYPE_UF:
        info->partition_num = 1;
        info->partition[0].block_size =  PARTITION_SIZE;
        info->partition[0].start_addr = UF_PARTITION_START;
        info->partition[0].size = UF_PARTITION_SIZE;
        break;
    case TUYA_FLASH_TYPE_KV_DATA:
        info->partition_num = 1;
        info->partition[0].block_size = FLH_BLOCK_SZ;
        info->partition[0].start_addr = SIMPLE_FLASH_START;
        info->partition[0].size = SIMPLE_FLASH_SIZE;
        break;
    case TUYA_FLASH_TYPE_KV_KEY:
        info->partition_num = 1;
        info->partition[0].block_size = FLH_BLOCK_SZ;
        info->partition[0].start_addr = SIMPLE_FLASH_KEY_ADDR;
        info->partition[0].size = FLH_BLOCK_SZ;
        break;
#if defined(KV_PROTECTED_ENABLE) && (KV_PROTECTED_ENABLE==1)
    case TUYA_FLASH_TYPE_KV_PROTECT:
        info->partition_num = 1;
        info->partition[0].block_size = PROTECTED_FLASH_HUGE_SZ;
        info->partition[0].start_addr = PROTECTED_DATA_ADDR;
        info->partition[0].size = PROTECTED_FLASH_HUGE_SZ;
        break;
#endif
    default:
        return OPRT_INVALID_PARM;
        break;
    }

    return OPRT_OK;
    // --- END: user implements ---
}


