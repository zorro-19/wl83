/**
 * @file tkl_network.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "tkl_network.h"
#include "tuya_error_code.h"

#include "lwip/sockets.h"
#include "lwip/netdb.h"
#include "lwip/inet.h"

#include "tal_log.h"
// --- END: user defines and implements ---

typedef struct NETWORK_ERRNO_TRANS {
    int sys_err;
    int priv_err;
} NETWORK_ERRNO_TRANS_S;
#define UNW_TO_SYS_FD_SET(fds)  ((fd_set*)fds)


const NETWORK_ERRNO_TRANS_S unw_errno_trans[] = {
    {EINTR, UNW_EINTR},
    {EBADF, UNW_EBADF},
    {EAGAIN, UNW_EAGAIN},
    {EFAULT, UNW_EFAULT},
    {EBUSY, UNW_EBUSY},
    {EINVAL, UNW_EINVAL},
    {ENFILE, UNW_ENFILE},
    {EMFILE, UNW_EMFILE},
    {ENOSPC, UNW_ENOSPC},
    {EPIPE, UNW_EPIPE},
    {EWOULDBLOCK, UNW_EWOULDBLOCK},
    {ENOTSOCK, UNW_ENOTSOCK},
    {ENOPROTOOPT, UNW_ENOPROTOOPT},
    {EADDRINUSE, UNW_EADDRINUSE},
    {EADDRNOTAVAIL, UNW_EADDRNOTAVAIL},
    {ENETDOWN, UNW_ENETDOWN},
    {ENETUNREACH, UNW_ENETUNREACH},
    {ENETRESET, UNW_ENETRESET},
    {ECONNRESET, UNW_ECONNRESET},
    {ENOBUFS, UNW_ENOBUFS},
    {EISCONN, UNW_EISCONN},
    {ENOTCONN, UNW_ENOTCONN},
    {ETIMEDOUT, UNW_ETIMEDOUT},
    {ECONNREFUSED, UNW_ECONNREFUSED},
    {EHOSTDOWN, UNW_EHOSTDOWN},
    {EHOSTUNREACH, UNW_EHOSTUNREACH},
    {ENOMEM, UNW_ENOMEM},
    {EMSGSIZE, UNW_EMSGSIZE}
};

/**
* @brief Get error code of network
*
* @param void
*
* @note This API is used for getting error code of network.
*
* @return 0 on success. Others on error, please refer to the error no of the target system
*/
TUYA_ERRNO tkl_net_get_errno(VOID)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_get_errno！");
    int i = 0;

    int sys_err = errno;

    for (i = 0; i < (int)sizeof(unw_errno_trans) / sizeof(unw_errno_trans[0]); i++) {
        if (unw_errno_trans[i].sys_err == sys_err) {
            TAL_PR_DEBUG("return unw_errno");
            return unw_errno_trans[i].priv_err;
        }
    }

    return -100 - sys_err;
    // --- END: user implements ---
}

/**
* @brief Add file descriptor to set
*
* @param[in] fd: file descriptor
* @param[in] fds: set of file descriptor
*
* @note This API is used to add file descriptor to set.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_fd_set(CONST INT_T fd, TUYA_FD_SET_T *fds)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_fd_set");
    if ((fd < 0) || (fds == NULL)) {
        TAL_PR_DEBUG("error fd<0 || fds is null");
        return -3000 + fd;
    }
//    put_buf(fds->placeholder, (TUYA_FD_MAX_COUNT+7)/8);
    FD_SET(fd, UNW_TO_SYS_FD_SET(fds));

    return UNW_SUCCESS;
    // --- END: user implements ---
}

/**
* @brief Clear file descriptor from set
*
* @param[in] fd: file descriptor
* @param[in] fds: set of file descriptor
*
* @note This API is used to clear file descriptor from set.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_fd_clear(CONST INT_T fd, TUYA_FD_SET_T *fds)
{
    // --- BEGIN: user implements ---
    if ((fd < 0) || (fds == NULL)) {
        return -3000 + fd;
    }
//    TAL_PR_DEBUG("tkl net fd clear");
    FD_CLR(fd, UNW_TO_SYS_FD_SET(fds));

    return UNW_SUCCESS;
    // --- END: user implements ---
}

/**
* @brief Check file descriptor is in set
*
* @param[in] fd: file descriptor
* @param[in] fds: set of file descriptor
*
* @note This API is used to check the file descriptor is in set.
*
* @return TRUE or FALSE
*/
OPERATE_RET tkl_net_fd_isset(CONST INT_T fd, TUYA_FD_SET_T *fds)
{
    // --- BEGIN: user implements ---
    if ((fd < 0) || (fds == NULL)) {
        return -3000 + fd;
    }
//    TAL_PR_DEBUG("tkl net fd isset");
//    printf("fd:%d",fd);
//    put_buf(fds->placeholder, 8);

    return FD_ISSET(fd, UNW_TO_SYS_FD_SET(fds));
    // --- END: user implements ---
}

/**
* @brief Clear all file descriptor in set
*
* @param[in] fds: set of file descriptor
*
* @note This API is used to clear all file descriptor in set.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_fd_zero(TUYA_FD_SET_T *fds)
{
    // --- BEGIN: user implements ---
    if (fds == NULL) {
        return 0xFFFFFFFF;
    }
//    TAL_PR_DEBUG("tkl net fd zero");
//    put_buf(fds->placeholder, (TUYA_FD_MAX_COUNT+7)/8);
    FD_ZERO(UNW_TO_SYS_FD_SET(fds));
    return UNW_SUCCESS;
    // --- END: user implements ---
}

/**
* @brief Get available file descriptors
*
* @param[in] maxfd: max count of file descriptor
* @param[out] readfds: a set of readalbe file descriptor
* @param[out] writefds: a set of writable file descriptor
* @param[out] errorfds: a set of except file descriptor
* @param[in] ms_timeout: time out
*
* @note This API is used to get available file descriptors.
*
* @return >0 the count of available file descriptors, <=0 error.
*/
INT_T tkl_net_select(CONST INT_T maxfd, TUYA_FD_SET_T *readfds, TUYA_FD_SET_T *writefds, TUYA_FD_SET_T *errorfds, CONST UINT_T ms_timeout)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl net select maxfd:%d", maxfd);

    if (maxfd <= 0) {
        return -3000 + maxfd;
    }

    struct timeval *tmp = NULL;
    struct timeval timeout = {ms_timeout / 1000, (ms_timeout % 1000) * 1000};
    if (0 != ms_timeout) {
        tmp = &timeout;
    } else {
        tmp = NULL;
    }
    int ret = select(maxfd, UNW_TO_SYS_FD_SET(readfds), UNW_TO_SYS_FD_SET(writefds), UNW_TO_SYS_FD_SET(errorfds), tmp);
//    printf("select return %d", ret);
    return ret;
    // --- END: user implements ---
}

/**
* @brief Get no block file descriptors
*
* @param[in] fd: file descriptor
*
* @note This API is used to get no block file descriptors.
*
* @return >0 the count of no block file descriptors, <=0 error.
*/
INT_T tkl_net_get_nonblock(CONST INT_T fd)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl net get nonblock");
    if (fd < 0) {
        return -3000 + fd;
    }

    if ((fcntl(fd, F_GETFL, 0) & O_NONBLOCK) != O_NONBLOCK) {
        return 0;
    }

    if (errno == EAGAIN || errno == EWOULDBLOCK) {
        return 1;
    }

    return 0 ;
    // --- END: user implements ---
}

/**
* @brief Set block flag for file descriptors
*
* @param[in] fd: file descriptor
* @param[in] block: block flag
*
* @note This API is used to set block flag for file descriptors.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_set_block(CONST INT_T fd, CONST BOOL_T block)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl net set block");
    if (fd < 0) {
        return -3000 + fd;
    }

    int flags = fcntl(fd, F_GETFL, 0);
    if (block) {
        flags &= (~O_NONBLOCK);
    } else {
        flags |= O_NONBLOCK;
    }

    if (fcntl(fd, F_SETFL, flags) < 0) {
        printf("失败");
        return UNW_FAIL;
    }
//    printf("成功");
    return UNW_SUCCESS;
    // --- END: user implements ---
}

/**
* @brief Close file descriptors
*
* @param[in] fd: file descriptor
*
* @note This API is used to close file descriptors.
*
* @return 0 on success. Others on error, please refer to the error no of the target system
*/
TUYA_ERRNO tkl_net_close(CONST INT_T fd)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl net net close");
    if (fd < 0) {
        return -3000 + fd;
    }
//    printf("fd:%d", fd);
    return close(fd);
    // --- END: user implements ---
}

/**
* @brief Shutdown file descriptors
*
* @param[in] fd: file descriptor
* @param[in] how: shutdown type
*
* @note This API is used to shutdown file descriptors.
*
* @return 0 on success. Others on error, please refer to the error no of the target system
*/
TUYA_ERRNO tkl_net_shutdown(CONST INT_T fd, CONST INT_T how)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl net net shutdown");
    if (fd < 0) {
        return -3000 + fd;
    }

    return shutdown(fd, how);
    // --- END: user implements ---
}

/**
* @brief Create a tcp/udp socket
*
* @param[in] type: protocol type, tcp or udp
*
* @note This API is used for creating a tcp/udp socket.
*
* @return file descriptor
*/
INT_T tkl_net_socket_create(CONST TUYA_PROTOCOL_TYPE_E type)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl net socket create");
    int fd = -1;
//    printf("type:%d", type);
    if (PROTOCOL_TCP == type) {
        fd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
    } else if (PROTOCOL_RAW == type) {
        fd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    } else {
        fd = socket(AF_INET, SOCK_DGRAM, 0);
    }
//    printf("tkl_net_socket_create fd:%d", fd);
    return fd;
    // --- END: user implements ---
}

/**
* @brief Connect to network
*
* @param[in] fd: file descriptor
* @param[in] addr: address information of server
* @param[in] port: port information of server
*
* @note This API is used for connecting to network.
*
* @return 0 on success. Others on error, please refer to the error no of the target system
*/
TUYA_ERRNO tkl_net_connect(CONST INT_T fd, CONST TUYA_IP_ADDR_T addr, CONST UINT16_T port)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl net connect");
    if (fd < 0) {
        return -3000 + fd;
    }
//    TAL_PR_DEBUG("fd:%d, addr:%x, port:%d", fd, addr, port);
    struct sockaddr_in sock_addr;
    unsigned short tmp_port = port;
    TUYA_IP_ADDR_T tmp_addr = addr;

    sock_addr.sin_family = AF_INET;
    sock_addr.sin_port = htons(tmp_port);
    sock_addr.sin_addr.s_addr = htonl(tmp_addr);
    int ret = connect(fd, (struct sockaddr *)&sock_addr, sizeof(struct sockaddr_in));

    if (ret < 0) {
        TAL_PR_DEBUG("tkl_net_connect error");
    } else {
        TAL_PR_DEBUG("tkl_net_connect ret:%d", ret);
    }

    return ret;
    // --- END: user implements ---
}

/**
* @brief Connect to network with raw data
*
* @param[in] fd: file descriptor
* @param[in] p_socket: raw socket data
* @param[in] len: data lenth
*
* @note This API is used for connecting to network with raw data.
*
* @return 0 on success. Others on error, please refer to the error no of the target system
*/
TUYA_ERRNO tkl_net_connect_raw(CONST INT_T fd, VOID *p_socket_addr, CONST INT_T len)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl net connect raw");
    if (fd < 0) {
        return -3000 + fd;
    }
    int ret = connect(fd, (struct sockaddr *)p_socket_addr, len);
    if (ret < 0) {
        TAL_PR_DEBUG("tkl_net_connect_raw error");
    } else {
        TAL_PR_DEBUG("tkl_net_connect_raw ret:%d", ret);
    }
    return ret;
    // --- END: user implements ---
}

/**
* @brief Bind to network
*
* @param[in] fd: file descriptor
* @param[in] addr: address information of server
* @param[in] port: port information of server
*
* @note This API is used for binding to network.
*
* @return 0 on success. Others on error, please refer to the error no of the target system
*/
TUYA_ERRNO tkl_net_bind(CONST INT_T fd, CONST TUYA_IP_ADDR_T addr, CONST UINT16_T port)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl net bind");
    if (fd < 0) {
        return -3000 + fd;
    }

    UINT16_T tmp_port = port;
    TUYA_IP_ADDR_T tmp_addr = addr;

    struct sockaddr_in sock_addr;
    sock_addr.sin_family = AF_INET;
    sock_addr.sin_port = htons(tmp_port);
    sock_addr.sin_addr.s_addr = htonl(tmp_addr);

    return bind(fd, (struct sockaddr *)&sock_addr, sizeof(struct sockaddr_in));
    // --- END: user implements ---
}

/**
* @brief Listen to network
*
* @param[in] fd: file descriptor
* @param[in] backlog: max count of backlog connection
*
* @note This API is used for listening to network.
*
* @return 0 on success. Others on error, please refer to the error no of the target system
*/
TUYA_ERRNO tkl_net_listen(CONST INT_T fd, CONST INT_T backlog)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl net listen");
    if (fd < 0) {
        return -3000 + fd;
    }

    return listen(fd, backlog);
    // --- END: user implements ---
}

/**
* @brief Listen to network
*
* @param[in] fd: file descriptor
* @param[out] addr: the accept ip addr
* @param[out] port: the accept port number
*
* @note This API is used for listening to network.
*
* @return 0 on success. Others on error, please refer to the error no of the target system
*/
TUYA_ERRNO tkl_net_accept(CONST INT_T fd, TUYA_IP_ADDR_T *addr, UINT16_T *port)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl net accept");
    if (fd < 0) {
        return -3000 + fd;
    }

    struct sockaddr_in sock_addr;
    socklen_t len = sizeof(struct sockaddr_in);
    int cfd = accept(fd, (struct sockaddr *)&sock_addr, &len);
    if (cfd < 0) {
        return UNW_FAIL;
    }

    if (addr) {
        *addr = ntohl((sock_addr.sin_addr.s_addr));
    }

    if (port) {
        *port = ntohs((sock_addr.sin_port));
    }

    return cfd;
    // --- END: user implements ---
}

/**
* @brief Send data to network
*
* @param[in] fd: file descriptor
* @param[in] buf: send data buffer
* @param[in] nbytes: buffer lenth
*
* @note This API is used for sending data to network
*
* @return >0 on num of send, <0 please refer to the error no of the target system
*/
TUYA_ERRNO tkl_net_send(CONST INT_T fd, CONST VOID *buf, CONST UINT_T nbytes)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl net send");
//    TAL_PR_DEBUG("fd: %d, nbytes:%d, port:%d", fd, nbytes);
//    put_buf(buf, nbytes);
//    puts(buf);
    if ((fd < 0) || (buf == NULL) || (nbytes == 0)) {
        return -3000 + fd;
    }
//    TAL_PR_DEBUG("fd: %d, nbytes:%d, addr:%d, port:%d", fd, nbytes);
//    puts(buf);
    int i = 0;
    int ret = send(fd, buf, nbytes, 0);
    if (ret < 0) {
        for (i = 0; i < 2; i++) {
            ret = send(fd, buf, nbytes, 0);
            if (ret >= 0) {
                break;
            }
        }
    }
    if (ret < 0) {
        user_printf("tuya_os_adapt_net_send err =%d\n", ret);
    }

    return ret;
    // --- END: user implements ---
}

/**
* @brief Send data to specified server
*
* @param[in] fd: file descriptor
* @param[in] buf: send data buffer
* @param[in] nbytes: buffer lenth
* @param[in] addr: address information of server
* @param[in] port: port information of server
*
* @note This API is used for sending data to network
*
* @return >0 on num of send, <0 please refer to the error no of the target system
*/
TUYA_ERRNO tkl_net_send_to(CONST INT_T fd, CONST VOID *buf, CONST UINT_T nbytes, CONST TUYA_IP_ADDR_T addr, CONST UINT16_T port)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl net send to");

//    printf("buf data:%s", buf);
    if ((fd < 0) || (buf == NULL) || (nbytes == 0)) {
        return -3000 + fd;
    }
//    TAL_PR_DEBUG("fd: %d, nbytes:%d, addr:%d, port:%d", fd, nbytes, addr, port);
//    printf("buf data:%s", buf);
    unsigned short tmp_port = port;
    TUYA_IP_ADDR_T tmp_addr = addr;

    struct sockaddr_in sock_addr;
    sock_addr.sin_family = AF_INET;
    sock_addr.sin_port = htons(tmp_port);
    sock_addr.sin_addr.s_addr = htonl(tmp_addr);

    return sendto(fd, buf, nbytes, 0, (struct sockaddr *)&sock_addr, sizeof(sock_addr));
    // --- END: user implements ---
}

/**
* @brief Receive data from network
*
* @param[in] fd: file descriptor
* @param[in] buf: receive data buffer
* @param[in] nbytes: buffer lenth
*
* @note This API is used for receiving data from network
*
* @return >0 on num of recv, <0 please refer to the error no of the target system
*/
TUYA_ERRNO tkl_net_recv(CONST INT_T fd, VOID *buf, CONST UINT_T nbytes)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl net recv");
    if ((fd < 0) || (buf == NULL) || (nbytes == 0)) {
        return -3000 + fd;
    }
//    printf("fd:%d, nbytes:%d", fd, nbytes);
//    put_buf(buf, nbytes);

    int flags = fcntl(fd, F_GETFL, 0);

    int noblock = flags & O_NONBLOCK;

//    printf("flags:%d, noblock:%d", flags, noblock);
    if (!noblock) {
        fd_set set;
        FD_ZERO(&set);
        FD_SET(fd, &set);
        if (select(fd + 1, &set, NULL, NULL, NULL) < 0) {
            printf("select error");
            return -1;
        }
    }
    int ret = recv(fd, buf, nbytes, 0);
//    printf("ret:%d", ret);
    return ret;
    // --- END: user implements ---
}

/**
* @brief Receive data from network with need size
*
* @param[in] fd: file descriptor
* @param[in] buf: receive data buffer
* @param[in] nbytes: buffer lenth
* @param[in] nd_size: the need size
*
* @note This API is used for receiving data from network with need size
*
* @return >0 on success. Others on error
*/
INT_T tkl_net_recv_nd_size(CONST INT_T fd, VOID *buf, CONST UINT_T buf_size, CONST UINT_T nd_size)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl net recv nd size");
    if ((fd < 0) || (NULL == buf) || (buf_size == 0) || \
        (nd_size == 0) || (buf_size < nd_size)) {
        return -3000 + fd;
    }

    unsigned int rd_size = 0;
    int ret = 0;

    while (rd_size < nd_size) {
        ret = recv(fd, ((uint8_t *)buf + rd_size), nd_size - rd_size, 0);
        if (ret <= 0) {
            TUYA_ERRNO err = tkl_net_get_errno();
            if (UNW_EWOULDBLOCK == err || UNW_EINTR == err || UNW_EAGAIN == err) {
                tkl_system_sleep(10);
                continue;
            }

            break;
        }

        rd_size += ret;
    }

    if (rd_size < nd_size) {
        return -2;
    }

    return rd_size;
    // --- END: user implements ---
}

/**
* @brief Receive data from specified server
*
* @param[in] fd: file descriptor
* @param[in] buf: receive data buffer
* @param[in] nbytes: buffer lenth
* @param[in] addr: address information of server
* @param[in] port: port information of server
*
* @note This API is used for receiving data from specified server
*
* @return >0 on num of recv, <0 please refer to the error no of the target system
*/
TUYA_ERRNO tkl_net_recvfrom(CONST INT_T fd, VOID *buf, CONST UINT_T nbytes, TUYA_IP_ADDR_T *addr, UINT16_T *port)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl net revfrom");
    if ((fd < 0) || (buf == NULL) || (nbytes == 0)) {
        return -3000 + fd;
    }

    struct sockaddr_in sock_addr;
    socklen_t addr_len = sizeof(struct sockaddr_in);
    int ret = recvfrom(fd, buf, nbytes, 0, (struct sockaddr *)&sock_addr, &addr_len);
    if (ret <= 0) {
        return ret;
    }

    if (addr) {
        *addr = ntohl(sock_addr.sin_addr.s_addr);
    }

    if (port) {
        *port = ntohs(sock_addr.sin_port);
    }

    return ret;
    // --- END: user implements ---
}

/**
* @brief Get address information by domain
*
* @param[in] domain: domain information
* @param[in] addr: address information
*
* @note This API is used for getting address information by domain.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_gethostbyname(CONST CHAR_T *domain, TUYA_IP_ADDR_T *addr)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_gethostbyname");
    if ((domain == NULL) || (addr == NULL)) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    struct hostent *h = NULL;
    if ((h = gethostbyname(domain)) == NULL) {
        return UNW_FAIL;
    }

    *addr = ntohl(((struct in_addr *)(h->h_addr_list[0]))->s_addr);

    return UNW_SUCCESS;
    // --- END: user implements ---
}

/**
* @brief Bind to network with specified ip
*
* @param[in] fd: file descriptor
* @param[in] ip: ip address
*
* @note This API is used for binding to network with specified ip.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_socket_bind(CONST INT_T fd, CONST CHAR_T *ip)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_socket_bind");
    if (NULL == ip) {
        return -3000;
    }

    struct sockaddr_in addr_client   = {0};
    addr_client.sin_family   = AF_INET;
    addr_client.sin_addr.s_addr      = inet_addr(ip);
    addr_client.sin_port     = 0;    /// 0 表示由系统自动分配端口号

    if (0 != bind(fd, (struct sockaddr *)&addr_client, sizeof(addr_client))) {
        return UNW_FAIL;
    }

    return UNW_SUCCESS;
    // --- END: user implements ---
}

/**
* @brief Set socket fd close mode
*
* @param[in] fd: file descriptor
*
* @note This API is used for setting socket fd close mode, the socket fd will not be closed in child processes generated by fork calls.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_set_cloexec(CONST INT_T fd)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_set_cloexec");
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
* @brief Get ip address by socket fd
*
* @param[in] fd: file descriptor
* @param[out] addr: ip address
*
* @note This API is used for getting ip address by socket fd.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_get_socket_ip(CONST INT_T fd, TUYA_IP_ADDR_T *addr)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_get_socket_ip");
    struct sockaddr_in sa;
    int addrlen = sizeof(sa);
    int ret = getsockname(fd, (struct sockaddr *)&sa, &addrlen);
    if (ret != 0) {
        printf("fd %d tkl_net_get_socket_ip err\n", fd);
        return -1;
    } else {
        printf("fd %d tkl_net_get_socket_ip ok\n", fd);
        *addr = ntohl(sa.sin_addr.s_addr);
        printf("addr:%d\n", *addr);
        return 0;
    }
    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief Change ip string to address
*
* @param[in] ip_str: ip string
*
* @note This API is used to change ip string to address.
*
* @return ip address
*/
TUYA_IP_ADDR_T tkl_net_str2addr(CONST CHAR_T *ip_str)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_str2addr");
    if (ip_str == NULL) {
        return 0xFFFFFFFF;
    }

    TUYA_IP_ADDR_T addr1 = inet_addr((char *)ip_str);
    TUYA_IP_ADDR_T addr2 = ntohl(addr1);

    return addr2;
    // --- END: user implements ---
}

/**
* @brief Change ip address to string
*
* @param[in] ipaddr: ip address
*
* @note This API is used to change ip address(in host byte order) to string(in IPv4 numbers-and-dots(xx.xx.xx.xx) notion).
*
* @return ip string
*/
CHAR_T *tkl_net_addr2str(CONST TUYA_IP_ADDR_T ipaddr)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_addr2str");
    return inet_ntoa(ipaddr);
    // --- END: user implements ---
}

/**
* @brief Set socket options
*
* @param[in] fd: file descriptor
* @param[in] level: setting level
* @param[in] optname: the name of the option
* @param[in] optval: the value of option
* @param[in] optlen: the length of the option value
*
* @note This API is used for setting socket options.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_setsockopt(CONST INT_T fd, CONST TUYA_OPT_LEVEL level, CONST TUYA_OPT_NAME optname, CONST VOID_T *optval, CONST INT_T optlen)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_setsockopt");
    if (fd < 0) {
        return -3000 + fd;
    }
    if (0 != setsockopt(fd, level, optname, (const char *)optval, optlen)) {
        return UNW_FAIL;
    }
    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief Get socket options
*
* @param[in] fd: file descriptor
* @param[in] level: getting level
* @param[in] optname: the name of the option
* @param[out] optval: the value of option
* @param[out] optlen: the length of the option value
*
* @note This API is used for getting socket options.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_getsockopt(CONST INT_T fd, CONST TUYA_OPT_LEVEL level, CONST TUYA_OPT_NAME optname, VOID_T *optval, INT_T *optlen)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_getsockopt");
    if (fd < 0) {
        return -3000 + fd;
    }
    if (0 != getsockopt(fd, level, optname, (const char *)optval, optlen)) {
        return UNW_FAIL;
    }
    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief Set timeout option of socket fd
*
* @param[in] fd: file descriptor
* @param[in] ms_timeout: timeout in ms
* @param[in] type: transfer type, receive or send
*
* @note This API is used for setting timeout option of socket fd.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_set_timeout(CONST INT_T fd, CONST INT_T ms_timeout, CONST TUYA_TRANS_TYPE_E type)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_set_timeout");
    if (fd < 0) {
        return -3000 + fd;
    }

    struct timeval timeout = {ms_timeout / 1000, (ms_timeout % 1000) * 1000};
    int optname = ((type == TRANS_RECV) ? SO_RCVTIMEO : SO_SNDTIMEO);

    if (0 != setsockopt(fd, SOL_SOCKET, optname, (char *)&timeout, sizeof(timeout))) {
        return UNW_FAIL;
    }
    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief Set buffer_size option of socket fd
*
* @param[in] fd: file descriptor
* @param[in] buf_size: buffer size in byte
* @param[in] type: transfer type, receive or send
*
* @note This API is used for setting buffer_size option of socket fd.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_set_bufsize(CONST INT_T fd, CONST INT_T buf_size, CONST TUYA_TRANS_TYPE_E type)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_set_bufsize");
    if (fd < 0) {
        return -3000 + fd;
    }

    int size = buf_size;
    int optname = ((type == TRANS_RECV) ? SO_RCVBUF : SO_SNDBUF);

    if (0 != setsockopt(fd, SOL_SOCKET, optname, (char *)&size, sizeof(size))) {
        return UNW_FAIL;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief Enable reuse option of socket fd
*
* @param[in] fd: file descriptor
*
* @note This API is used to enable reuse option of socket fd.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_set_reuse(CONST INT_T fd)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_set_reuse");
    if (fd < 0) {
        return -3000 + fd;
    }

    int flag = 1;
    if (0 != setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (const char *)&flag, sizeof(int))) {
        printf("SO_REUSEADDR fail\r\n");
        return UNW_FAIL;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief Disable nagle option of socket fd
*
* @param[in] fd: file descriptor
*
* @note This API is used to disable nagle option of socket fd.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_disable_nagle(CONST INT_T fd)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_disable_nagle");
    if (fd < 0) {
        return -3000 + fd;
    }

    int flag = 1;
    if (0 != setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (const char *)&flag, sizeof(int))) {
        printf("disable_nagle fail\r\n");
        return UNW_FAIL;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief Enable broadcast option of socket fd
*
* @param[in] fd: file descriptor
*
* @note This API is used to enable broadcast option of socket fd.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_set_broadcast(CONST INT_T fd)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_set_broadcast");
    if (fd < 0) {
        return -3000 + fd;
    }

    int flag = 1;
    if (0 != setsockopt(fd, SOL_SOCKET, SO_BROADCAST, (const char *)&flag, sizeof(int))) {
        return UNW_FAIL;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief Set keepalive option of socket fd to monitor the connection
*
* @param[in] fd: file descriptor
* @param[in] alive: keepalive option, enable or disable option
* @param[in] idle: keep idle option, if the connection has no data exchange with the idle time(in seconds), start probe.
* @param[in] intr: keep interval option, the probe time interval.
* @param[in] cnt: keep count option, probe count.
*
* @note This API is used to set keepalive option of socket fd to monitor the connection.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_set_keepalive(INT_T fd, CONST BOOL_T alive, CONST UINT_T idle, CONST UINT_T intr, CONST UINT_T cnt)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_set_keepalive");
    if (fd < 0) {
        return -3000 + fd;
    }

    int ret = 0;
    int keepalive = alive;
    int keepidle = idle;
    int keepinterval = intr;
    int keepcount = cnt;

    ret |= setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (void *)&keepalive, sizeof(keepalive));
    ret |= setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, (void *)&keepidle, sizeof(keepidle));
    ret |= setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, (void *)&keepinterval, sizeof(keepinterval));
    ret |= setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, (void *)&keepcount, sizeof(keepcount));
    if (0 != ret) {
        user_printf("SO_KEEPALIVE fail\r\n");
        //return UNW_FAIL;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief Get socket name
*
* @param[in] fd: file descriptor
* @param[out] addr: ip address
* @param[out] port: port information
*
* @note This API is used to Get the current name for the specified socket
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_getsockname(INT_T fd, TUYA_IP_ADDR_T *addr, UINT16_T *port)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_getsockname");
    struct sockaddr_in sa;
    int addrlen = sizeof(sa);
    int ret = getsockname(fd, (struct sockaddr *)&sa, &addrlen);
    if (ret != 0) {
        printf("fd %d getsockname err\n", fd);
        return -1;
    } else {
        printf("fd %d getsockname ok\n", fd);
        *port = ntohs(sa.sin_port);
        *addr = ntohl(sa.sin_addr.s_addr);
        printf("port:%d\n", *port);
        printf("addr:%d\n", *addr);
        return 0;
    }
    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief Get name of connected peer socket
*
* @param[in] fd: file descriptor
* @param[out] addr: ip address
* @param[out] port: port information
*
* @note This API is used to Get the name of connected peer socket.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_getpeername(INT_T fd, TUYA_IP_ADDR_T *addr, UINT16_T *port)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_getpeername");
    struct sockaddr_in peerAddr;
    int peerLen = sizeof(peerAddr);
    int ret = getpeername(fd, (struct sockaddr *)&peerAddr, &peerLen);
    if (ret < 0) {
        printf("fd:%d getpeername err.\n", fd);
        return -1;
    }
    *port = ntohs(peerAddr.sin_port);
    *addr = ntohl(peerAddr.sin_addr.s_addr);
    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief Set the system hostname
*
* @param[in] hostname: hostname to set
*
* @note This API is used to set the system hostname.
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_net_sethostname(CONST CHAR_T *hostname)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_sethostname");
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief get netif by index
 *
 * @param[in]       net_if_idx    the num of netif index
 * @return  NULL: get netif fail   other: the point of netif
 */
PVOID_T tkl_net_get_netif_by_index(CONST TUYA_NETIF_TYPE_E net_if_idx)
{
    // --- BEGIN: user implements ---
//    TAL_PR_DEBUG("tkl_net_get_netif_by_index");
    return 0;
    // --- END: user implements ---
}

